25603	frank_mueller	support ada 95 passive partitions in a distribute environment	ada 95 passive partition contain passive library unit provide the means to distribute datum within a network of workstation this paper show how passive partition can be implement via distribute shared virtual memory lrb dsm rrb dsm provide the logical view of a portion of memory share between physically distribute workstation within a network in this paper we relate design issue and operational characteristic of dsm system to the semantics of shared passive library unit as speciied in the ada 95 distribute system annex we design and implement such a dsm system operate at the granularity of page in a portable fashion over posix thread the dsm system establish its own communication service and be completely independent of any ada runtime system support protect object be support via a novel prioritized protocol for distribute mutual exclusion we integrate the dsm system with the gnu ada translator lrb gnat rrb and its environment to support active partition the dsm system integration require minimal change to the gnat environment and remain completely transparent to the user and the ada runtime system this be the rst implementation of shared passive library unit within a ada 95 compilation environment to we knowledge the dsm support can provide considerable performance advantage over alternative approach with repeat remote access since with dsm only the rst access to remote datum result in communication overhead while consecutive access may take the same time as local memory access use the dsm paradigm distribute application can be design to access distribute shared datum eeciently furthermore the shared memory model inherent to the ada language can be use without modiication in a distribute environment doi 101007 354063114320 granularity workstation shared data dsm communication overhead	Ada-Europe	
42344	frank_mueller david_b._whalley	fast instruction cache analysis via static cache simulation	this paper introduce a new method for instruction cache analysis that outperform conventional tracedriven method the new method static cache simulation analyze a program for a give cache configuration and determine prior to execution time if a instruction reference will always result in a cache hit or miss at run time counter be increment to provide the execution frequency of portion of code in addition the cache behavior be simulated for reference that could not be predict statically the dynamic simulation employ a novel view of the cache by update local state information associate with code portion the total number of cache hit and miss can be infer from the frequency counter at program exit measurement take from a variety of program show that this new method speed up cache analysis over conventional tracedriven method by almost a order of a magnitude thus cache analysis with static cache simulation make it possible to analyze the instruction cache behavior of longer and more realistic program execution doi 101109 simsym 1995393589 cache simulation cache analysis hit instruction cache simulator	Annual_Simulation_Symposium	Dept._of_Comput._Sci. Florida_State_Univ. Tallahassee FL
77632	ramnath_venugopalan prasanth_ganesan pushkin_peddabachagari alexander_g._dean frank_mueller mihail_l._sichitiu	encryption overhead in embedded system and sensor network node modeling and analysis	recent research in sensor network have raise issue of security for small embedded device security concern be motivate by the deployment of a large number of sensory device in the field limitations in process power battery life communication bandwidth and memory constrain the applicability of exist cryptography standard for small embedded device a mismatch between wide arithmetic for security lrb 32 bit word operation rrb and embedded datum bus width lrb often only 8 or 16 bit rrb combine with lack of certain operation lrb eg multiply rrb in the isa present other challengesthis paper offer two contribution first a survey investigate the computational requirement for e a number of common cryptographic algorithm and embedded architecture be present the objective of this work be to cover a wide class of commonly use encryption algorithm and to determine the impact of embedded architecture on they performance this will help designer predict a system s performance for cryptographic task second method to derive the computational overhead of embedded architecture in general for encryption algorithm be develop this allow one to project computational limitation and determine the threshold of feasible encryption scheme under a set of the constraint for a embedded architectureexperimental measurement indicate uniform cryptographic cost for each encryption class and each architecture class and negligible impact of cache rc4 be show to outperform rc5 for the atmega platform but when message authentication be require in addition to encryption hash or block cipher such as rc5 have the advantage of provide support for both authentication and encryption the analytical model allow to assess the impact of arbitrary embedded architecture as a multivariant function for each encryption scheme overall we result be not only valuable to assess the feasibility of encryption scheme for exist embedded architecture they also extend to assess the feasibility of encryption method for new algorithm and architecture for sensor system doi 101145 951710951737 authentication embed architecture small embed devices cipher encryption	CASES	North_Carolina_State_University Raleigh NC
86591	jaydeep_marathe frank_mueller tushar_mohan bronis_r._de_supinski sally_a._mckee andy_yoo	metric tracking down inefficiencies in the memory hierarchy via binary rewriting	in this paper we present metric a environment for determine memory inefficiency by examine datum trace metric be design to alter the performance behavior of application that be mostly constrain by they latency to resolve memory reference we make four primary contribution in this paper first we present method to extract partial datum trace from run application by observe they memory behavior via dynamic binary rewrite second we present a methodology to represent partial datum trace in constant space for regular reference through a novel technique for online compression of reference stream third we employ offline cache simulation to derive indication about memory performance bottleneck from partial datum trace by exploit summarize memory metric byreference metric as well as cache evictor information we can pinpoint the source of performance problem fourth we demonstrate the ability to derive opportunity for optimization and assess they benefit in several experiment result in up to 40 lower miss ratio metric data trace constant size rsd multiple loop	CGO	Dept._of_Comput._Sci. North_Carolina_State_Univ. Raleigh NC USA
197551	sebastian_unger frank_mueller	handle irreducible loop optimize node split vs djgraph	this paper address the question of how to handle irreducible region during optimization which have become even more relevant for contemporary processor since recent vliwlike architecture highly rely on instruction scheduling the contribution of this paper be twofold first a method of optimize node splitting to transform irreducible region of control flow into reducible region be formally define and its correctness be show this method be superior to approach previously publish since it reduce the number of replicate node by comparison second three method that handle region of irreducible control flow be evaluate with respect to they impact on compiler optimization first traditional node splitting be evaluate second optimize node splitting be implement third djgraph be utilize to recognize nesting of irreducible lrb and reducible rrb loop and apply common loop optimization extend for irreducible loop experiment compare the performance of these approach with unrecognized irreducible loop that can not be subject to loop optimization which be typical for contemporary compiler measurement show improvement of 1 to 40 percnt for these method of handle irreducible loop over the unoptimized case optimize node splitting may be choose to retrofit exist compiler since it have the advantage that it only require few change to a optimize compiler while limit the code growth of compile program compare to traditional node splitting recognize loop via djgraph should be choose for new compiler development since it require more change to the optimizer but do not significantly change the code size of compile program while yield comparable improvement handle irreducible loop should even yield more benefit for exploit instructionlevel parallelism of modern architecture in the context of global instruction scheduling and optimization technique that may introduce irreducible loop such as enhance modulo scheduling doi 101145 567097567098 control flow reducible latter techniques sophisticated compiler node split irreducible instruction scheduling	Euro-Par	
197594	claus_wagner frank_mueller	tokenbased readwritelock for distribute mutual exclusion		Euro-Par	
296650	nirmit_desai frank_mueller	scalable distribute concurrency services for hierarchical lock	middleware component be become increasingly important as application share computational resource in distribute environment one of the main challenge in such environment be to achieve scalability of concurrency control exist concurrency protocol lack scalability scalability enable resource sharing and computing with distribute object in system with a large number of node we have design and implement a novel scalable and fully decentralize middleware concurrency control protocol we experiment on a linux cluster indicate that a average number of three message be require per lock request on a system with as many as 120 which be a logarithmic asymptote at the same time the response time for the request scale linearly with the increase in concurrency level a comparison to another scalable concurrency protocol show that we protocol result in significantly superior asymptotic savings in message overhead and response time for large number of node while we approach follow the specification of general corba concurrency service for largescale datum and object repository the principle be applicable to any distribute concurrency service and transaction model the result of this work impact scalability for distribute computing facility range from embedded computing with distribute object over peertopeer computing environment to arbitrate access in very large database environment doi 101109 icdcs 20031203504 concurrency corba middleware message overhead reliance	ICDCS	Dept._of_Comput._Sci. North_Carolina_State_Univ. Raleigh NC USA
345099	chao_wang zhe_zhang sudharshan_s._vazhkudai xiaosong_ma frank_mueller	onthefly recovery of job input data in supercomputers	storage system failure be a serious concern as we approach petascale computing even at today s subpetascale level io failure be the lead cause of downtime and job failure we contribute a novel onthefly recovery framework for job input datum into supercomputer parallel file system the framework exploit key trait of the hpc io workload to reconstruct lose input datum during job execution from remote immutable copy each reconstructed datum stripe be make immediately accessible in the client request order due to the delay metadata update and finegranular lock while unrelated access to the same file remain unaffected we have implement the recovery component within the lustre parallel file system thus build a novel applicationtransparent online recovery solution we solution be integrate into lustre s twolevel lock scheme use a twophase block protocol combine parametric and simulation study we experiment demonstrate a significant improvement in hpc center service ability and user job turnaround time doi 101109 icpp 200828 lustre hpc centers io pfs file systems	ICPP	
360500	jaydeep_marathe frank_mueller bronis_r._de_supinski	a hybrid hardwaresoftware approach to efficiently determine cache coherence bottleneck	highend computing increasingly rely on sharedmemory multiprocessor lrb smp rrb such as cluster of smp node of chipmultiprocessor lrb cmp rrb or largescale singlesystem image lrb ssi rrb smp in such system performance be often affect by the sharing pattern of datum within application and its impact on cache coherence share pattern that result in frequent invalidation follow by subsequent coherence miss create cache coherence bottleneck with significant performance penalty past work on identify coherence bottleneck base oil trace memory access incur considerable runtime overhead and do not scale well with increase problem size which make it infeasible to use with realworld programsin this paper we introduce a novel lowcost hardwareassisted approach to determine coherence bottleneck in sharedmemory openmp application we assess the merit of we approach on a contemporary smp platform specifically we assess the feasibility of lossy trace to pinpoint coherence problem in application we evaluate the qualitative and quantitative tradeoff between trace overhead and accuracy of the generate coherence traffic metric correlate to memory access point at the program source levelour lossy trace mechanism closely approximate the degree of accuracy of determine coherence miss in full trace for most of the benchmark we study while reduce runtime execution overhead and trace size by one to two order of magnitude to the best of we knowledge this novel method significantly outperform any of the prior approach and for the first time make cache coherence analysis feasible for longrunning application doi 101145 10881491088153 coherence smp	ICS	North_Carolina_State_University Raleigh NC
360502	jaydeep_marathe anita_nagarajan frank_mueller	detailed cache coherence characterization for openmp benchmark	past work on study cache coherence in sharedmemory symmetric multiprocessor lrb smp rrb concentrate on study aggregate event often from a architecture point of view however this approach provide insufficient information about the exact source of inefficiency in parallel application for smp in contemporary cluster application performance be impact by the pattern of share memory usage and it become essential to understand coherence behavior in term of the application program construct such as datum structure and source code linesthe technical contribution of this work be as follow we introduce ccsim a cachecoherent memory simulator feed by datum trace obtain through onthefly dynamic binary rewrite of openmp benchmark execute on a power3 smp node we explore the degree of freedom in interleave datum trace from the different processor and assess the simulation accuracy by compare with hardware performance counter the novelty of ccsim lie in its ability to relate coherence traffic specifically coherence miss as well as they progenitor invalidation to datum structure and to they reference location in the source program thereby facilitate the detection of inefficiency we experiment demonstrate that lrb a rrb cache coherence traffic be simulated accurately for spmd programming style as its invalidation traffic closely match the corresponding hardware performance counter lrb b rrb we derive detailed coherence information indicate the location of invalidation in the application code i ie i source line and datum structure and lrb c rrb we illustrate opportunity for optimization from these detail by exploit these unique feature of ccsim we be able to identify and locate opportunity for program transformation include interaction with openmp construct result in both significantly decrease coherence miss and savings of up to 73 in wallclock execution time for several realworld benchmark doi 101145 10062091006250 real smp coherence performance counter invalidation inefficiency cation	ICS	North_Carolina_State_University Raleigh NC
360837	jyothish_varma chao_wang frank_mueller christian_engelmann stephen_l._scott	scalable fault tolerant membership for mpi task on hpc system	reliability be increasingly become a challenge for highperformance computing lrb hpc rrb system with thousand of node such as ibm s blue genel a shorter meantimetofailure can be address by add fault tolerance to reconfigure work node to ensure that communication and computation can progress however exist approach fall short in provide scalability and small recon guration overhead within the faulttolerant layerthis paper contribute a scalable approach to recon gure the communication infrastructure after node failure we propose a decentralize lrb peertopeer rrb protocol that maintain a consistent view of active node in the presence of fault we protocol show response time in the order of hundred of microsecond and singledigit millisecond for recon guration use mpi over bluegenel and tcp over gigabit respectively the protocol can be adapt to match the network topology to further increase performance we also verify experimental result against a performance model which demonstrate the scalability of the approach hence the membership service be suitable for deployment in the communication layer of mpi runtime system and we have integrate a early version into lammpi doi 101145 11834011183433 lamd ibm mpi hpc systems ing	ICS	North_Carolina_State_University Raleigh NC
360886	arun_babu_nagarajan frank_mueller christian_engelmann stephen_l._scott	proactive fault tolerance for hpc with xen virtualization	largescale parallel computing be rely increasingly on cluster with thousand of processor at such large count of compute node fault be become common place current technique to tolerate fault focus on reactive scheme to recover from fault and generally rely on a checkpointrestart mechanism yet in today s system node failure can often be anticipate by detect a deteriorate health status instead of a reactive scheme for fault tolerance lrb ft rrb we be promote a proactive one where process automatically migrate from unhealthy node to healthy one we approach rely on operate system virtualization technique exemplify by but not limit to xen this paper contribute a automatic and transparent mechanism for proactive ft for arbitrary mpi application it leverage virtualization technique combine with health monitoring and loadbased migration we exploit xen s live migration mechanism for a guest operating system lrb os rrb to migrate a mpi task from a healthdeteriorating node to a healthy one without stop the mpi task during most of the migration we proactive ft daemon orchestrate the task of health monitoring load determination and initiation of guest os migration experimental result demonstrate that live migration hide migration cost and limit the overhead to only a few seconds make it a attractive approach to realize ft in hpc system overall we enhancement make proactive ft a valuable asset for longrunning mpi application that be complementary to reactive ft use full checkpointrestart scheme since checkpoint frequency can be reduce as fewer unanticipated failure be encounter in the context of i os virtualization i we believe that this be the first comprehensive study of proactive fault tolerance where live migration be actually trigger by health monitoring doi 101145 12749711274978 fault tolerance hpc mpi virtualization virtual machine	ICS	North_Carolina_State_University Raleigh NC
360924	prasun_ratn frank_mueller bronis_r._de_supinski martin_schulz	preserve time in largescale communication trace	analyze the performance of largescale scientific application be become increasingly difficult due to the sheer size of performance datum gather recent work on scalable communication trace apply online interprocess compression to address this problem yet analysis of communication trace require knowledge about time progression that can not trivially be encode in a scalable manner during compression we develop scalable time stamp encode scheme for communication trace at the same time we work contribute novel insight into the scalable representation of time stamped datum we show that we representation capture sufficient information to enable whatif exploration of architectural variation and analysis for pathbased timing irregularity while not require excessive disk space we evaluate the ability of several timestamped compress mpi trace approach to enable accurate time replay of communication event we lossless trace be order of magnitude smaller if not near constant size regardless of the number of node while preserve timing information suitable for application tuning or assess requirement of future procurement we result prove timepreserving trace without loss of communication information can scale in the number of node and time step which be a result without precedent doi 101145 13755271375537 communication trace scalatrace number of node replay parallel application	ICS	North_Carolina_State_University Raleigh NC USA
408733	nirmit_desai frank_mueller	a log lrb n rrb multimode locking protocol for distribute systems	trend in highend cluster be to deploy a ever larger number of processor to push the envelope on parallelizing scientific application a similar trend exist in server computing where more and more server be compose into a farm one of the main challenge in such environment be to achieve scalability of synchronization specifically for lock we work focus on scalable lock in distribute system at its essence be a peertopeer protocol for multimode hierarchical lock which be applicable to transactionstyle processing and distribute agreement we demonstrate high scalability combine with low response time in highperformance cluster environment we experiment on a ibm sp show that the number of message approach a asymptote at 15 node from which point on the message overhead be in the order of 39 message per request depend on system parameter at the same time response time increase linearly with a proportional increase in request and consequently higher concurrency level we observe response time under 2 and 10 msec for up to 25 and 80 node for critical section that be one 25th the size of noncritical code we approach benefit in large from high level of concurrency upon resolve request and dynamic path compression for request propagation besides its technical strength we approach be intriguing due to its simplicity and its wide applicability range from largescale cluster to serverstyle computing doi 101109 ipdps 20031213077 concurrency large ment lock ibm	IPDPS	Dept._of_Comput._Sci. North_Carolina_State_Univ. Raleigh NC USA
410137	frank_mueller	faulttolerance for tokenbased synchronization protocol	the contribution of this paper be twofold first a general method to support fault tolerance for tokenbased synchronization protocol in distribute system be introduce contrary to traditional approach this new method use a decentralized approach to recover from node failure under failstop condition neither do it require a centralized manager nor broadcast support second the method be demonstrate by adopt the protocol for mutual exclusion by naimi et al lsb 21 rsb to tolerate fault a implementation of the new protocol in a distribute execution environment provide fault detection with fault recovery and false alarm detection experiment with different fault injection scenario underline the feasibility of this new approach measurement indicate that we protocol inflict no overhead in the absence of fault and a factor 5 to 10 overhead in the presence of fault doi 101109 ipdps 2001925101 fault tolerance fault detection smp mutual exclusion token	IPDPS	Humboldt_University_Berlin
410138	frank_mueller	timing analysis in search of multiple paradigm	summary form only give while timing analysis be a vital prerequisite for realtime schedulability test prior advance on timing analysis be sometimes incremental in address select new processor feature or limited source code annotation to provide safe but tight wcet bound in contrast recent advance in timing analysis include a refreshing set of novel approach to bind the worstcase execution time lrb wcet rrb of realtime task these advance be in search of new methodology to address the timing analysis problem and approach this problem in a more general manner example be 1 rrb the complexity wall of hardware that cause timing analysis tool to trail behind the curve of microarchitectural innovation 2 rrb severe restriction on the knowledge of loop bound 3 rrb the inability to analysis large application program 4 rrb a lack of capitalize on opportunity of dynamic scheduler interaction and 5 rrb the challenge in express certainty level of wcet bound we give a overview of select approach and contribute a initial account on the potential of the contribution for the field each of these novel approach to timing analysis solve one problem in current toolset it appear that the diversity of approach be a valuable asset to the research area while a particular solution may prove best suitable for some problem another approach may be require for different problem furthermore many of the recent advance be complement each other some can be use in conjunction to provide additional robustness to hard realtime system doi 101109 ipdps 20041303090 hard wcet fast analysis tool timing analysis	IPDPS	Dept._of_Comput._Sci. North_Carolina_State_Univ. Raleigh NC USA
410139	frank_mueller	prioritize tokenbased mutual exclusion for distribute systems	a number of solution have be propose for the problem of mutual exclusion in distribute system some of these approach have since be extend to a prioritized environment suitable for realtime application but impose a higher message pass overhead than we approach we present a new protocol for prioritize mutual exclusion in a distribute environment we approach use a tokenbased model work on a logical tree structure which be dynamically modii in addition we utilize a set of local queue whose union would resemble a single global queue the prioritize algorithm have a average overhead of o lrb log lrb n rrb rrb message per request for mutual exclusion with a worstcase overhead of o lrb n rrb where n represent the number of node in the system thus we prioritize algorithm match the message complexity of the best nonprioritized algorithm while previous prioritized algorithm have a higher message complexity to we knowledge furthermore the concept of local queue can be incorporate into arbitrary tokenbased protocol with or without priority support to reduce the amount of message doi 101109 ipps 1998670018 mutual exclusion fifo queue forwarding message complexity	IPPS/SPDP	Inst._fur_Inf. Humboldt-Univ. Berlin
410140	frank_mueller	adaptive dsmbehavior via speculative datum distribution		IPPS/SPDP_Workshops	
410142	frank_mueller jorg_nolte alexander_schlaefer	clix a hybrid programming environment for distribute object and distribute share memory		IPDPS_Workshops	
411139	jeffrey_s._vetter frank_mueller	communication characteristic of largescale scientific application for contemporary cluster architecture	this paper examine the explicit communication characteristic of several sophisticated scientific application which by themselves constitute a representative suite of publicly available benchmark for large cluster architecture by focus on the message passing interface lrb mpi rrb and by use hardware counter on the microprocessor we observe each application s inherent behavioral characteristic pointtopoint and collective communication and floatingpoint operation furthermore we explore the sensitivity of these characteristic to both problem size and number of processor we analysis reveal several striking similarity across we diverse set of application include the use of collective operation especially those collective with very small datum payload we also highlight a trend of novel application parting with regimented static communication pattern in favor of dynamically evolve pattern as evidence by we experiment on application that use implicit linear solver and adaptive mesh refinement overall we study contribute a better understanding of the requirement of current and emerge paradigm of scientific computing in term of they computation and communication demand doi 101109 ipdps 20021015504 scientific application collective operation communication characteristic mpi parallel application	IPDPS	Center_for_Appl._Sci._Comput. Lawrence_Livermore_Nat._Lab. CA
412098	michael_noeth frank_mueller martin_schulz bronis_r._de_supinski	scalable compression and replay of communication trace in massively p arallel e nvironment	characterize the communication behavior of largescale application be a difficult and costly task due to code and system complexity as well as the time to execute such code a alternative to run actual code be to gather they communication trace and then replay they which facilitate application tuning and future procurement while past approach lack lossless scalable trace collection we contribute a approach that provide near constantsize communication trace regardless of the number of node while preserve structural information we introduce intra and internode compression technique of mpi event and present result of we implementation give this novel capability we discuss its impact on communication tuning and beyond doi 101145 11884551188605 communication trace poster number of node replay structural information mpi temporal	IPDPS	Dept._of_Comput._Sci. North_Carolina_State_Univ. Raleigh NC
412194	chao_wang frank_mueller christian_engelmann stephen_l._scott	a job pause service under lammpi blcr for transparent fault tolerance	checkpointrestart lrb cr rrb have become a requirement for longrunning job in largescale cluster due to a meantimetofailure lrb mttf rrb in the order of hour after a failure cr mechanism generally require a complete restart of a mpi job from the last checkpoint a complete restart however be unnecessary since all but one node be typically still alive furthermore a restart may result in lengthy job requeuing even though the original job have not exceed its time quantum in this paper we overcome these shortcoming instead of job restart we have develop a transparent mechanism for job pause within lammpi blcr this mechanism allow live node to remain active and roll back to the last checkpoint while fail node be dynamically replace by spare before resume from the last checkpoint we methodology include lammpi enhancement in support of scalable group communication with fluctuate number of node reuse of network connection transparent coordinate checkpoint scheduling and a blcr enhancement for job pause experiment in a cluster with the nas parallel benchmark suite show that we overhead for job pause be comparable to that of a complete job restart a minimal overhead of 56 be only incur in case migration take place while the regular checkpoint overhead remain unchanged yet we approach alleviate the need to reboot the lam runtime environment which account for considerable overhead result in net savings of we scheme in the experiment we solution further provide full transparency and automation with the additional benefit of reuse exist resource execute continue after failure within the schedule job ie the application staging overhead be not incur again in contrast to a restart we scheme offer additional potential for savings through incremental checkpointing and proactive diskless live migration which we be currently work on doi 101109 ipdps 2007370307 blcr checkpointing lammpi mpi api	IPDPS	Dept._of_Comput._Sci. North_Carolina_State_Univ. Raleigh NC
418485	aravindh_anantaraman kiran_seth kaustubh_patil eric_rotenberg frank_mueller	virtual simple architecture lrb visa rrb exceed the complexity limit in safe realtime systems	meet deadline be a key requirement in safe realtime system worstcase execution time lrb wcet rrb of task be need for safe planning contemporary worstcase timing analysis tool can safely and tightly bind execution time on inorder singleissue pipeline with cache and static branch prediction however this simple pipeline appear to be a complexity limit due to the need for analyzability this exclude a whole class of highperformance processor from many embedded systemswe reconcile the complexitysafety tradeoff by decouple worstcase timing analysis from the processor implementation through a virtual simple architecture lrb visa rrb a visa be the timing specification of a hypothetical simple pipeline and be the basis for worstcase timing analysis however the underlie microarchitecture can be arbitrarily complex a task be divide into multiple subtask which provide a means to gauge progress on the complex pipeline each subtask be assign a interim deadline or checkpoint base on the latest allowable completion time of the subtask on the hypothetical simple pipeline if no checkpoint be miss then the complex pipeline be as timely as the safe pipeline if a checkpoint be miss the pipeline switch to a simple mode of operation that directly implement the visa so that execution time of unfinished subtask be safely bound the significance of we approach be that we circumvent worstcase timing analysis of the complex pipeline by dynamically confirm its behavior be bound by worstcase timing analysis of a simpler proxy pipelinethe benefit of use a highperformance processor be that task finish much sooner than they would have on a explicitlysafe processor the new slack in the schedule can be exploit for higher throughput or lower power with the visa approach a arbitrarily complex smt processor can safely run nonrealtime task at the same time as a realtime task alternatively frequencyvoltage can be safely lower to take up slack we explore the latter application and show a visacompliant complex pipeline consume 43 61 less power than a explicitlysafe pipeline doi 101145 859618859659 visa pipeline slack realtime task dvf	ISCA	
450958	daniel_schulz frank_mueller	a threadaware debugger with a open interface	while thread have become a accept and standardized model for express concurrency and exploit parallelism for the sharedmemory model debug thread be still poorly support this paper identify challenge in debug thread and offer solution to they the contribution of this paper be threefold first a open interface for debug as a extension to thread implementation be propose second extension for threadaware debugging be identify and implement within the gnu debugger to provide additional feature beyond the scope of exist debugger third a active debug framework be propose that include a languageindependent protocol to communicate between debugger and application via relational query ensure that the enhancement of the debugger be independent of actual thread implementation partial or complete implementation of the interface for debugging can be add to thread implementation to work in unison with the enhance debugger without any modification to the debugger itself sample implementation of the interface for debug have show its adequacy for userlevel thread kernel thread and mixed thread implementation while provide extended debugging functionality at improve efficiency and portability at the same time doi 101145 347324349141 debugging debugger thread implementations open interface	ISSTA	Humboldt_Univ. Berlin Germany
466779	nirmit_desai frank_mueller	a brief overview of scalable distribute concurrency service for hierarchical lock	as researcher share computational resource such as object in large distribute environment it become difficult to achieve scalability of synchronization and commonly use concurrency protocol currently lack scalability we peertopeer protocol enhance middleware concurrency service to provide scalability of synchronization enable resource sharing and computing with distribute object in system with a large number of node doi 101145 583810583838	Java_Grande	North_Carolina_State_University Raleigh NC
483537	frank_mueller	compiler support for softwarebased cache partitioning	cache memory have become a essential part of modern processor to bridge the increase gap between fast processor and slower main memory until recently cache memory be think to impose unpredictable execution time behavior for hard realtime system but recent result show that the speedup of cache can be exploit without a significant sacrifice of predictability these result be obtain under the assumption that realtime task be schedule b nonpreemptively b this paper introduce a method to maintain predictability of execution time within b preemptive b cache realtime system and discuss the impact on compilation support for such a system preemptive system with cache be make predictable via softwarebased cache partitioning with this approach the cache be divide into distinct portion associate with a realtime task such that a task may only use its portion the compiler have to support instruction and datum partition for each task instruction partitioning involve nonlinear controlflow transformation while datum partition involve code transformation of datum reference the impact on execution time of these transformation be also discuss doi 101145 216636216677 cache partitioning compilation predictability operating realtime systems	Workshop_on_Languages,_Compilers,_Tools_for_Real-Time_Systems	
483645	ajay_dudani frank_mueller yifan_zhu	energyconserving feedback edf scheduling for embedded system with realtime constraint	embed system have limit energy resource hence they should conserve these resource to extend they period of operation recently dynamic frequency scaling lrb dfs rrb and dynamic voltage scaling lrb dvs rrb have be add to a various embedded processor as a means to increase battery life a number of scheduling technique have be develop to exploit dfs and dvs for realtime system to reduce energy consumption these technique exploit idle and slack time of a schedule idle time can be consume by lower the processor frequency of select task while slack time allow later task to execute at lower frequency with reduce voltage demandsour work deliver energy savings beyond the level of prior work we enhance the earliestdeadline first lrb edf rrb scheduling to exploit slack time generate by the invocation of the task at multiple frequency level i within the same invocation i the technique rely strictly on operate system support within the scheduler to implement the approach early scale at a low frequency determine by a feedback mechanism and facilitate by a slackpassing scheme capitalize on high probability of a task to finish its execution without utilize its worstcase execution budget if a task do not complete at a certain point in time within its low frequency range the remainder of it continue to execute at a higher frequency we experiment demonstrate that the result energy savings exceed those of previously publish work by up to 33 in addition we method only add a constant complexity at each scheduling point which have not be achieve by prior work to the best of we knowledge doi 101145 513829513865 dvs slack energy save dfs	LCTES-SCOPES	North_Carolina_State_University Raleigh NC
483695	kaustubh_patil kiran_seth frank_mueller	compositional static instruction cache simulation	scheduling in hard realtime system require a priori knowledge of worstcase execution time lrb wcet rrb obtain the wcet of a task be a difficult problem static timing analysis technique approach this problem via path analysis pipeline simulation and cache simulation to derive safe wcet bound but such analysis have traditionally be constrain to only small program due to the complexity of simulation most notably the complexity of static cache simulation which require interprocedural analysisthis paper describe a novel approach of compositional static cache simulation that alleviate the complexity problem thereby make static timing analysis feasible for much larger program than in the past specifically a framework be contribute that facilitate static cache analysis by splitting it into two step a modulelevel analysis and a compositional phase thus address the issue of complexity of interprocedural analysis for a entire program the modulelevel analysis parameterize the dataflow information in term of potential eviction from cache due to call contain conflict reference the compositional analysis stage use the result of the parameterized dataflow for each module thus the emphasis here be on handle most of the complexity in the modulelevel analysis and perform as little analysis as possible at the compositional level the experimental result for directmapped instruction cache show that the compositional analysis framework outperform prior analysis method for larger program by one to two order of magnitude depend on the reference for comparison while provide equally accurate prediction this novel approach to static cache analysis provide a promising solution to the complexity problem in timing analysis which for the first time make the analysis of larger program feasible doi 101145 997163997183 cache simulation wcet static cache analysis interprocedural analysis timing analysis	LCTES	
483703	yifan_zhu frank_mueller	dvsleak combine leakage reduction and voltage scaling in feedback edf scheduling	recent trend in cmos fabrication have the demand to conserve power of processor while dynamic voltage scaling lrb dvs rrb be effective in reduce dynamic power microprocessor produce in ever smaller fabrication process be increasingly dominate bystatic power for such processor voltagefrequency pair below acritical speed result in higher energy per cycle than enter a processor sleep mode yet computational demand above this critical speed be best meet by dvs technique while still conserve power we develop a novel combined leakage and dvs scheduling algorithm forrealtime system dvs leak base on earliestdeadlinefirst scheduling lrb edf rrb we method trade off dv with leakage where the former slow down execution while the latter intelligently defer dispatch of job when sleep be beneficial we further capitalize on feedback knowledge about actual execution time to anticipate computational demand without sacrifice deadline guarantee as such we contribute a novel feedback delay policy for leakage awareness which address structural limitation of prior approach experiment show that this combined dvsleakage algorithm result in a average of lrb a rrb 50 additional energy savings over a leakageoblivious dvs algorithm lrb b rrb 20 more energy savings over a more simplistic combination of dvs and sleep policy and lrb c rrb 85 or more over dynamic slack reclamation with procrastination particularly task set with period shorter than ten millisecond profit from we approach with 15 energy savings over best prior scheme this make dvs leak the best combine dvsleakage regulation approach for realtime system that we know of doi 101145 12547661254772 dvs leakage energy saving realtime systems	LCTES	North_Carolina_State_University Raleigh NC
483743	joel_coffman christopher_a._healy frank_mueller david_b._whalley	generalize parametric timing analysis	in the design of realtime and embedded system it be important to establish a bind on the worstcase execution time lrb wcet rrb of program to assure via schedulability analysis that deadline be not miss static wcet analysis be perform by a timing analysis tool this paper describe novel improvement to such a tool allow parametric timing analysis to be perform parametric timing analyzer receive a upper bind on the number of loop iteration in term of a expression which be use to create a parametric formula this parametric formula be later evaluate to determine the wcet base on input value only know at runtime effect a transformation from a numeric to a parametric timing analyzer require two innovation 1 rrb a summation solver capable of summation nonconstant expression and 2 rrb a polynomial datum structure which can replace integer as the basis for all calculation both addition permit other method of analysis lrb eg caching pipeline constraint rrb to occur simultaneously combine these technique allow we tool to statically bind the wcet for a larger class of benchmark doi 101145 12547661254795 wcet parametric formula	LCTES	North_Carolina_State_University Raleigh NC
483787	emilio_vivancos christopher_a._healy frank_mueller david_b._whalley	parametric timing analysis	embed system often have realtime constraint traditional timing analysis statically determine the maximum execution time of a task or a program in a realtime system these system typically depend on the worstcase execution time of task in order to make static scheduling decision so that task can meet they deadline static determination of worstcase execution time impose numerous restriction on realtime program which include that the maximum number of iteration of each loop must be know statically these restriction can significantly limit the class of program that would be suitable for a realtime embedded system this paper describe workinprogress that use static timing analysis to aid in make dynamic scheduling decision for instance different algorithm with vary level of accuracy may be select base on the algorithm s predict worstcase execution time and the time allot for the task we represent the worstcase execution time of a function or a loop as a formula where the unknown value affect the execution time be parameterize this i	LCTES/OM	Lawrence_Livermore_National_Laboratory Livermore CA USA
483800	yifan_zhu frank_mueller	feedback edf scheduling exploit hardwareassisted asynchronous dynamic voltage scaling	recent processor support for dynamic frequency and voltage scaling lrb dvs rrb allow software to affect power consumption by vary execution frequency and supply voltage on the fly however processor generally enter a sleep state while transition between frequenciesvoltages in this paper we examine the merit of hardwaresoftware codesign for a feedback dvs algorithm and a novel processor capable of execute instruction during frequencyvoltage transition we study several poweraware feedback scheme base on earliestdeadlinefirst lrb edf rrb scheduling that adjust the system behavior dynamically for different workload characteristic a infrastructure for investigate several hard realtime dvs scheme include we feedback dvs algorithm be implement on a ibm powerpc 405lp embedded board architecture and algorithm overhead be assess for different dvs scheme measurement on the experimentation board provide a quantitative assessment of the potential of energy savings for dvs algorithm as oppose to prior simulation work that could only provide trend energy consumption measure through a data acquisition board indicate a considerable potential for realtime dvs scheduling algorithm to lower energy up to 64 over the na 239 ve dvs scheme we feedback dvs algorithm save at least as much and often considerably more energy than previous dvs algorithm with peak savings of a additional 24 energy reduction to the best of we knowledge this be the first comparative study of realtime dvs algorithm on a concrete microarchitecture and the first evaluation of asynchronous dvs switching doi 101145 10659101065939 save supply voltage dvs scheme dvs algorithm	LCTES	North_Carolina_State_University Raleigh NC
522561	frank_mueller antony_l._hosking	penumbra a eclipse plugin for introductory programming	eclipse be a fullfeatured and easily extensible integrate development environment as such it have grow to include a large degree of functionality that may be overwhelming to the novice programmer nevertheless we believe eclipse be a environment that student of programming will come to find useful and empower once they become familiar with it the trick be ease they into use eclipse without they feel overwhelm at the outset penumbra be a eclipse plugin develop at purdue university for use in we introductory programming class it be intend to ease the transition to use of the fullfeatured functionality of eclipse penumbra present a eclipse perspective that hide all but the basic action of eclipse s exist java perspective while packaging element of other perspective lrb eg the cvs perspective rrb into simpler action that ease the downloading and turnin of programming assignment and add new code view inspire by other environment for introductory programmer we experience use eclipse with a small group of introductory programming student in the spring of 2003 have guide the development of penumbra which be now be roll out for general use by the full class of 230 student in the fall of 2003 doi 101145 965660965674 eclipse penumbra introductory programming	OOPSLA_Workshop_on_Eclipse_Technology_eXchange	Purdue_University West_Lafayette IN
536343	frank_mueller	on the design and implementation of dsmthread	this paper discuss design goal design decision and implementation choice of dsmthread a runtime system to support distribute thread with a distribute shared virtual memory lrb dsm rrb dsmthread provide a distribute runtime system with a kernel on each node which rely on posix thread locally and a decentralize communication subsystem between node support for multiple datum consistency protocol facilitate the migration from sharedmemory posix thread to dsmthread in a distribute environment on one side and ooer opportunity to netune the program for dsmthread on the other side the overall approach enhance portability of the system and allow support for heterogeneous environment without modiication of compiler or operate system the paper also describe the support for higherorder distribute language feature by example for ada95 finally a rst evaluation of the system s performance be give dsmthread be to we knowledge the rst runtime system to support distribute thread on top of posix threads via distribute virtual shared memory smp modiication posix shared memory dsm	PDPTA	
538001	frank_mueller david_b._whalley marion_g._harmon	realtime debugging by minimal hardware simulation	this paper describe a debug environment for realtime application that support the query of the elapsed time at breakpoint the environment employ hardware simulation at the level of processor cycle the hardware simulation be limit only to the aspect relevant to processor cycle accounting and include instruction caching instruction frequency accounting and instruction pipelining this simulation be perform by program instrumentation to minimize the performance impact thus the environment provide the means to debug a realtime application for a embedded system on a regular workstation in a eecient manner doi 101007 97836427939297 debugging deadline hardware simulation embed	PEARL	
542755	frank_mueller david_b._whalley	avoid unconditional jump by code replication	this study evaluate a global optimization technique that avoid unconditional jump by replicate code when implement in the backend of a optimize compiler this technique can be generalize to work on almost all instance of unconditional jump include those generate from conditional statement and unstructured loop the replication method be base on the idea of find a replacement for each unconditional jump which minimize the growth in code size this be achieve by choose the shortest sequence of instruction as a replacement measurement take from a variety of program show that not only the number of execute instruction decrease but also that the total cache work be reduce lrb except for small cache rrb despite increase in code size pipelined and superscalar machine may also benefit from a increase in the average basic block size doi 101145 143095143144 live range code transformation code replication code size unconditional jumps	PLDI	
542756	frank_mueller david_b._whalley	avoid conditional branch by code replication	summary onchip instruction cache areincrease in size compiler writer aree xploit this fact by apply a variety of optimization that improve the execution performance of a program at the expense of increase its code size this paper describe a new optimization that can be use to avoid conditional branch by replicate code the central idea be to determine if thereare path wheret he result of a conditional branch will be know and to replicate code to exploit it algorithm be describe for detect when branch area voidable forr estructure the control flowt oa void these branch and for position the replicate block in the restructure code the result indicate that the optimization can be frequently apply with reduction in both the number of instruction execute and total instruction cache work doi 101145 207110207116 live range control flow conditional branches code transformation code size	PLDI	
548411	jaydeep_marathe frank_mueller	hardware profileguided automatic page placement for ccnuma system	cache coherent nonuniform memory architecture lrb ccnuma rrb constitute a important class of highperformance computing platform contemporary ccnuma system such as the sgi altix have a large number of node where each node consist of a small number of processor and a fix amount of physical memory all processor in the system access the same global virtual address space but the physical memory be distribute across node and coherence be maintain use hardware mechanism access to local physical memory lrb on the same node as the request processor rrb result in lower latency than access to remote memory lrb on a different node rrb since many scientific program be memorybound a intelligent pageplacement policy that allocate page closer to the request processor can significantly reduce number of cycle require to access memory we show that such a policy can lead to significant savings in wallclock execution timein this paper we introduce a novel hardwareassisted page placement scheme base on automate profiling the placement scheme allocate page near processor that most frequently access that page the scheme leverage performance monitoring capability of contemporary microprocessor to efficiently extract a approximate trace of memory access this information be use to decide i page affinity ie i the node to which the page be bind we method operate entirely in user space be widely automate and handle not only static but also dynamic memory allocationwe evaluate we framework with a set of multithreaded benchmark from the nas and spec openmp suite we investigate the use of two different hardware profile source with respect to the cost lrb eg time to trace number of record in profile rrb vs the accuracy of the profile and the corresponding savings in wallclock execution time we show that longlatency load provide a better indicator for page placement than tlb missesour experiment show that we method can efficiently improve page placement lead to a average wallclock execution time saving of more than 20 for we benchmark with a onetime profiling overhead of 27 over the overall original program wallclock time to the best of we knowledge this be the first evaluation on a real machine of a completely user mode interruptdriven profileguided page placement scheme that require no special compiler operate system or network interconnect support doi 101145 11229711122987 profiling saving remote memory page placement memory access	PPOPP	North_Carolina_State_University Raleigh NC
548602	stephen_l._scott christian_engelmann geoffroy_vallee thomas_naughton anand_tikotekar george_ostrouchov chokchai_leangsuksun nichamon_naksinehaboon raja_nassar mihaela_paun frank_mueller chao_wang arun_babu_nagarajan jyothish_varma	a tunable holistic resiliency approach for highperformance computing system	in order to address anticipated high failure rate resiliency characteristic have become a urgent priority for nextgeneration extremescale highperformance computing lrb hpc rrb system this poster describe we past and ongoing effort in novel fault resilience technology for hpc present work include proactive fault resilience technique system and application reliability model and analysis failure prediction transparent process and virtualmachinelevel migration and tradeoff model for combine preemptive migration with checkpointrestart this poster summarize we work and put all individual technology into context with a propose holistic fault resilience framework doi 101145 15041761504227 resiliency fault tolerance reconfiguration poster monitor datum hpc	PPOPP	North_Carolina_State_University Raleigh NC USA
563956	sibin_mohan frank_mueller david_b._whalley christopher_a._healy	timing analysis for sensor network nodes of the atmega processor family	lowend embedded architecture such as sensor node have become popular in diverse field many of which impose realtime constraint currently the atmel atmega processor family use by berkeley motes lack support for derive safe bound on the wcet which be a prerequisite for perform realtime schedulability analysis we work fill this gap by provide a analytical method to obtain wcet bound for this processor architecture we first contribution be to analyze both c and nesc code the latter of which be unprecedented the second contribution be to model control hazard and variablecycle instruction both handle more efficiently by we approach than by previous one and result in up to 77 improvement in bound the wcet the result demonstrate that we timing analysis framework be able to tightly and safely estimate the wcet of the benchmark while simulator result be show to not always provide safe wcet bound while motivate by the atmel atmega series of processor result be equally applicable to lowend embedded processor this work be to the best of we knowledge the first set of experiment where timing result be contrast from execution on a actual processor from a cycleaccurate simulator and from a static timing analyzer furthermore make we timing analysis toolset available to the atmel atmega processor family be a significant contribution towards address a document need for tool support for sensor node architecture commonly use in networked system of embedded computer or socalled emnet doi 101109 rtas 200553 wcet timing analysis toolset worstcase execution time	IEEE_Real-Time_and_Embedded_Technology_and_Applications_Symposium	North_Carolina_State_University Raleigh
563976	frank_mueller joachim_wegener	a comparison of static analysis and evolutionary test for the verification of timing constraint	this paper contrast two method to verify timing constraint of realtime application the method of static analysis predict the worstcase and bestcase execution time of a task s code by analyze execution path and simulate processor characteristic without ever execute the program or require the program s input evolutionary testing be a iterative testing procedure which approximate the extreme execution time within several generation by execute the test object dynamically and measure the execution time the input be guide yield gradually tighter prediction of the extreme execution time we examine both approach on a number of real world example the result show that static analysis and evolutionary testing be complementary method which together provide upper and lower bound for both worstcase and bestcase execution time doi 101109 rttas 1998683198 wcet actual evolutionary testing schedulability static analysis	IEEE_Real_Time_Technology_and_Applications_Symposium	
564061	harini_ramaprasad frank_mueller	bound worstcase data cache behavior by analytically deriving cache reference patterns	while cache have become invaluable for higherend architecture due to they ability to hide in part the gap between processor speed and memory access time cache lrb and particularly datum cache rrb limit the timing predictability for datum access that may reside in memory or in cache this be a significant problem for realtime system the objective we work be to provide accurate prediction of datum cache behavior of scalar and nonscalar reference whose reference pattern be know at compile time such knowledge about cache behavior provide the basis for significant improvement in bound the worstcase execution time lrb wcet rrb of realtime program particularly for hardtoanalyze datum cache we exploit the power of the cache miss equation lrb cme rrb framework but lift a number of limitation of traditional cme to generalize the analysis to more arbitrary program we further devise a transformation coin force loop fusion which facilitate the analysis across sequential loop we contribution result in exact datum cache reference pattern minus in contrast to approximate cache miss behavior of prior work experimental result indicate improvement on the accuracy of worstcase datum cache behavior up to two order of magnitude over the original approach in fact we result closely bind and sometimes even exactly match those obtain by tracedriven simulation for worstcase input the result wcet bound of timing analysis confirm these finding in term of provide tight bound overall we contribution lift analytical approach to predict datum cache behavior to a level suitable for efficient static timing analysis and subsequently realtime schedulability of task with predictable wcet doi 101109 rtas 200512 sis loop nest data cache wcet analysis cache behavior	IEEE_Real-Time_and_Embedded_Technology_and_Applications_Symposium	North_Carolina_State_University
564062	harini_ramaprasad frank_mueller	bound preemption delay within data cache reference patterns for realtime tasks	cache have become invaluable for higherend architecture to hide in part the increase gap between processor speed and memory access time while the effect of cache on timing predictability of single realtime task have be the focus of much research bound the overhead of cache warmup after preemption remain a challenging problem particularly for datum cache in this paper we bind the penalty of cache interference for realtime task by provide accurate prediction of the datum cache behavior across preemption for every task we derive datum cache reference pattern for all scalar and nonscalar reference partial timing of a task be perform up to a preemption point use these pattern the effect of cache interference be then analyze use a settheoretic approach which identify the number and location of additional miss due to preemption a feedback mechanism provide the means to interact with the timing analyzer which subsequently time another interval of a task bound by the next preemption we experimental result demonstrate that it be sufficient to consider the n most expensive preemption point where n be the maximum possible number of preemption further it be show that such accurate modeling of datum cache behavior in preemptive system significantly improve the wcet prediction for a task to the best of we knowledge we work of bound preemption delay for datum cache be unprecedented doi 101109 rtas 200614 data cache wcet preemption preemptive	IEEE_Real_Time_Technology_and_Applications_Symposium	North_Carolina_State_University
564139	randall_t._white christopher_a._healy david_b._whalley frank_mueller marion_g._harmon	timing analysis for datum cache and setassociative cache	the contribution of this paper be twofold first a automatic toolbased approach be describe to bind worstcase datum cache performance the give approach work on fully optimize code perform the analysis over the entire control ow of a program detect and exploit both spatial and temporal locality within datum reference produce result typically within a few seconds and estimate on average 30 tighter wcet bound than can be predict without analyze datum cache behavior result obtain by run the system on representative program be present and indicate that timing analysis of datum cache behavior can result in signiicantly tighter worstcase performance prediction second a framework to bind worstcase instruction cache performance for setassociative cache be formally introduce and operationally describe result of incorporate instruction cache prediction within pipeline simulation show that timing prediction for setassociative cache remain just as tight as prediction for directmapped cache the cache simulation overhead scale linearly with increase associativity doi 101109 rttas 1997601358 wcet analyzer data cache setassociative cache worstcase	IEEE_Real_Time_Technology_and_Applications_Symposium	Dept._of_Comput._Sci. Florida_State_Univ. Tallahassee FL
564158	wankang_zhao william_c._kreahling david_b._whalley christopher_a._healy frank_mueller	improving wcet by optimize worstcase path	it be advantageous to perform compiler optimization to lower the wcet of a task since task with lower wcet be easier to schedule and more likely to meet they deadline compiler writer in recent year have use profile information to detect the frequently execute path in a program and there have be much effort to develop compiler optimization to improve these path in order to reduce averagecase execution time in this paper we describe we approach to reduce wcet by adapt and apply optimization design for frequent path to the worstcase path in a application we compiler use feedback from we timing analyzer to detect the wcet path through a function that will be subject to aggressive optimization reflect subsequent effect on the wcet of the path due to these optimization and to also ensure that the worstcase path optimization actually improve the wcet before commit to a code size increase we evaluate a number of wc path optimization and present result show the decrease in wcet versus the increase in code size doi 101109 rtas 200529 compiler optimization superblock wcet code size worstcase path	IEEE_Real-Time_and_Embedded_Technology_and_Applications_Symposium	North_Carolina_State_University Raleigh NC
564159	wankang_zhao prasad_kulkarni david_b._whalley christopher_a._healy frank_mueller gang-ryung_uh	tune the wcet of embed application	it be advantageous to not only calculate the wcet of a application but to also perform transformation to reduce the wcet since a application with a lower wcet will be less likely to violate its timing constraint in this paper we describe a environment consist of a interactive compilation system and a timing analyzer w herea user can interactively tune the wcet of a application after eacho ptimization phase be apply the timing analyzer be automatically invoke to calculate the wcet of the function be tune thus a user can easily gauge the progress of reduce the wceti na ddition the user can apply a genetic algorithm to search for a effective optimization sequence that best reduce the wcetu sing the genetic algorithm we show that the wcet for a number of application can be reduce by 7 on average as compare to the default batchoptimization sequence wcet timing constraint compilation dev timing analyzer	IEEE_Real-Time_and_Embedded_Technology_and_Applications_Symposium	
564164	yifan_zhu frank_mueller	feedback edf schedule exploit dynamic voltage scale	dynamic voltage scaling lrb dvs rrb be a promising method for embedded system to exploit multiple voltage and frequency level and to prolong battery life however pure dvs technique do not perform well for system with dynamic workload where the job execution time vary significantly we present a novel approach combine feedback control with dvs scheme target hard realtime system with dynamic workload we method rely strictly on operate system support by integrate a dvs scheduler and a feedback controller within the edf scheduling algorithm each task be divide into two portion within the first portion the objective be to exploit frequency scaling for the average execution time we reserve enough time for the second portion to meet the deadline requirement up to the worstcase execution time follow a lastchance approach feedback technique make the system capable to select the right frequency and voltage setting for the first potion as well as guarantee hard realtime requirement for the overall task simulation experiment demonstrate the ability of we algorithm to save up to 29 more energy than previous work for task set with different dynamic workload characteristic doi 101109 rttas 20041317252 hard dvs feedback control edf realtime systems	IEEE_Real-Time_and_Embedded_Technology_and_Applications_Symposium	
564178	harini_ramaprasad frank_mueller	bound worstcase response time for task with nonpreemptive region	realtime schedulability theory require a priori knowledge of the worstcase execution time lrb wcet rrb of every task in the system fundamental to the calculation of wcet be a scheduling policy that determine priority among task such policy can be nonpreemptive or preemptive while the former reduce analysis complexity and overhead in implementation the latter provide increase flexibility in term of schedulability for higher utilization of arbitrary task set in practice task often have nonpreemptive region but be otherwise schedule preemptively to bind the wcet of task architectural feature have to be consider in the context of a scheduling scheme in particular preemption affect cache which can be model by bound the cacherelated preemption delay lrb crpd rrb of a task in this paper we propose a framework that provide safe and tight bound of the datacache related preemption delay lrb dcrpd rrb the wcet and the worstcase response time not just for homogeneous task under fully preemptive or fully nonpreemptive system but for task with a nonpreemptive region by retain the option of preemption where legal task set become schedulable that might otherwise not be yet by require a region within a task to be nonpreemptive correctness be ensure in term of arbitration of access to share resource experimental result confirm a increase in schedulability of a task set with non preemptive region over a equivalent task set where only those task with nonpreemptive region be schedule non preemptively altogether quantitative result further indicate that dcrpd bound and responsetime bound comparable to task set with fully nonpreemptive task can be retain in the presence of short nonpreemptive region to the best of we knowledge this be the first framework that perform dcrpd calculation in a system for task with a nonpreemptive region doi 101109 rtas 200818 nonpreemptive region task set preemption wcet schedulability	IEEE_Real-Time_and_Embedded_Technology_and_Applications_Symposium	Dept._of_Comput._Sci. North_Carolina_State_Univ. Raleigh NC
564199	sibin_mohan frank_mueller	hybrid timing analysis of modern processor pipelines via hardwaresoftware interaction	embed system be often subject to constraint that require determinism to ensure that task deadline be meet such system be refer to as realtime system schedulability analysis provide a firm basis to ensure that task meet they deadline for which knowledge of worstcase execution time lrb wcet rrb bound be a critical piece of information static timing analysis technique be use to derive these wcet bound a limit factor for design realtime system be the class of processor that can be use typically modern complex processor pipeline can not be use in realtime system design contemporary processor with they advanced architectural feature such as outoforder execution branch prediction speculation prefetching etc can not be statically analyze to obtain tight wcet bound for task this be cause by the nondeterminism of these feature which surface in full only at runtime in this paper we introduce a new paradigm to perform timing analysis of task for realtime system run on modern processor architecture we propose minor enhancement to the processor architecture to enable this process these feature on interaction with software module be able to obtain tight accurate timing analysis result for modern processor we also briefly present analysis technique that combine with we timing analysis method reduce the complexity of worstcase estimation for loop to the best of we knowledge this method of constant interaction between hardware and software to calculate wcet bound for outoforder processor be the first of its kind doi 101109 rtas 200819 wcet buffer snapshot timing analysis realtime systems	IEEE_Real-Time_and_Embedded_Technology_and_Applications_Symposium	Dept._of_Comput._Sci. North_Carolina_State_Univ. Raleigh NC
564993	aravindh_anantaraman kiran_seth eric_rotenberg frank_mueller	enforce safety of realtime schedules on contemporary processors use a virtual simple architecture lrb visa rrb	determine safe and tight upper bound on the worstcase execution time lrb wcet rrb of hard realtime task run on contemporary microarchitecture be a difficult problem current trend in microarchitecture design have create a complexity wall by enhance performance through ever more complex architectural feature system have become increasingly hard to analyze this paper extend a framework introduce previously as virtual simple architecture lrb visa rrb to multitasking realtime system the objective of visa be to obviate the need to statically analyze complex processor by instead shift the burden of guarantee deadline in part onto the hardware the visa framework exploit a complex processor that ordinarily operate with all of its advanced feature enable call the complex mode but which can also be downgrade to a simple mode by gate off the advanced feature a wcet bind be statically derive for a task assume the simple mode however this abstraction be speculatively undermine at runtime by execute the task in the complex mode the task s progress be continuously gauge to detect anomalous case in which the complex mode underperform in which case the processor switch to the simple mode to explicitly enforce the overall contractual wcet the processor typically operate in complex mode generate significant slack and the visa safety mechanism ensure bound timing in atypical case extra slack can be exploit for reduce power consumption andor enhance functionality by extend visa from singletask to multitasking system this paper reveal the full extent of visa s powerful abstraction capability key miss piece be fill in lrb 1 rrb preserve integrity of the gauge mechanism despite disruption cause by preemption lrb 2 rrb demonstrate compatibility with arbitrary scheduling and dynamic voltage scaling lrb dvs rrb policy lrb 3 rrb formally describe visa speculation overhead in term of padding task wcet and lrb 4 rrb develop a systematic method for minimize these overhead we also propose a novel visa variant that dynamically accrue the slack need to facilitate speculation in the complex mode eliminate the need to statically pad wcet and thereby enable visastyle speculation even in highlyutilized system doi 101109 real 200419 wcet visa headstart speculation simple mode	RTSS	North_Carolina_State_University
565015	robert_d._arnold frank_mueller david_b._whalley marion_g._harmon	bound worstcase instruction cache performance	the use of cache pose a difficult tradeoff for architect of realtime system while cache provide significant performance advantage they have also be view as inherently unpredictable since the behavior of a cache reference depend upon the history of the previous reference the use of cache will only be suitable for realtime system if a reasonably tight bind on the performance of program use cache memory can be predict this paper describe a approach for bound the worstcase instruction cache performance of large code segment first a new method call static cache simulation be use to analyze a program s control flow to statically categorize the caching behavior of each instruction a timing analyzer which use the categorization information then estimate the worstcase instruction cache performance for each loop and function in the program doi 101109 real 1994342718 cache analysis wcet int timing analyzer worstcase	IEEE_Real-Time_Systems_Symposium	Dept._of_Comput._Sci. Florida_State_Univ. Tallahassee FL
565366	sibin_mohan frank_mueller william_hawkins michael_root christopher_a._healy david_b._whalley	parascale exploit parametric timing analysis for realtime schedulers and dynamic voltage scale	static timing analysis safely bound worstcase execution time to determine if task can meet they deadline in hard realtime system however conventional timing analysis require that the upper bind of loop be know statically which limit its applicability parametric timing analysis method remove this constraint by provide the wcet as a formula parameterize on loop bound this paper contribute a novel technique to allow parametric timing analysis to interact with dynamic realtime scheduler by dynamically detect actual loop bound a lower wcet bind can be calculate onthefly for the remain execution of a task we analyze the benefit from parametric analysis in term of dynamically discover slack in a schedule we then assess the potential for dynamic power conservation by exploit parametric loop bound for parascale we intratask dynamic voltage scaling lrb dvs rrb approach we result demonstrate that the parametric approach to timing analysis provide 66 80 additional savings in power consumption we further show that use this approach combine with online intratask dvs to exploit parametric execution time result in much lower power consumption hence even in the absence of dynamic scheduling significant savings in power can be obtain eg in the case of cyclic executive doi 101109 rtss 200533 save wcet dvs pta loop bounds	RTSS	North_Carolina_State_University
565380	frank_mueller viresh_rustagi ted_baker	mithos a realtime microkernel threads operating system	mithos lrb microkernel thread operate system rrb be a experimental operating system for embedded system the system kernel be a rst implementation of the posix minimal realtime system proole it be base on prior work of a library implementation of pthreads lrb posix thread rrb the system be fully preemptive it support multithreading within a single process environment with shared kernel and user space ie realtime task be map onto posix thread it exhibit remarkable timing predictability intend for hard realtime requirement this be achieve by a careful design of only few device driver the system have be implement and test on the sparc vme architecture the system include a fast context switching algorithm for the sparc which outperform the context switch under sunos and match the performance under solaris it support selective enable and disable of hardware component lrb mmu cache etc rrb since its source be available furthermore a implementationdeened extension of posix thread for deadline scheduling be present overall the system exhibit slightly faster performance than sunos 4x and be considerably more predictable in its timing behavior application of the kernel range from evaluate the overhead of new language feature in ada 95 and its runtime system verify static timing prediction on a bare machine to provide the operating system for small embedded system that require a high timing predictability doi 101109 real 1995495195 interrupt dow con ker sparc	IEEE_Real-Time_Systems_Symposium	Humboldt-Univ. Berlin
565473	kiran_seth aravindh_anantaraman frank_mueller eric_rotenberg	fast frequencyaware static timing analysis	energy be a valuable resource in embedded system as the lifetime of many such system be constrain by they battery capacity recent advance in processor design have add support for dynamic frequencyvoltage scaling lrb dvs rrb for save energy recent work on realtime scheduling focus on save energy in static as well as dynamic scheduling environment by exploit idle time and slack because of early task completion for dvs of subsequent task these scheduling algorithm rely on i a priori i knowledge of worstcase execution time lrb wcet rrb for each task they assume that dvs have no effect on the worstcase execution cycle lrb wcec rrb of a task and scale the wcet accord to the processor frequency however for system with memory hierarchy the wcec typically i do i change under dvs because of requency modulation hence current assumption use by dvs scheme result in a highly exaggerated wcet this paper contribute novel technique for tight and flexible static timing analysis particularly wellsuited for dynamic scheduling scheme the technical contribution be as follow lrb 1 rrb we assess the problem of change execution cycle owe to scale technique lrb 2 rrb we propose a parametric approach toward bound the wcet statically with respect to the frequency use a parametric model we can capture the effect of change in frequency on the wcec and thus accurately model the wcet over any frequency range lrb 3 rrb we discuss design and implementation of the frequencyaware static timing analysis lrb fast rrb tool base on we prior experience with static timing analysis lrb 4 rrb we demonstrate in experiment that we fast tool provide safe upper bound on the wcet which be tight the fast tool allow we to capture the wcet of six benchmark use equation that overestimate the wcet by less than 1 percnt fast equation can also be use to improve exist dvs scheduling scheme to ensure that the effect of frequency scaling on wcet be consider and that the wcet use be i not i exaggerated lrb 5 rrb we leverage three dvs scheduling scheme by incorporate fast into they and by show that the energy consumption further decrease lrb 6 rrb we compare experimental result use two different energy model to demonstrate or verify the validity of simulation method to the best of we knowledge this study of dvs effect on timing analysis be unprecedented doi 101145 11323571132364 wcet fast dvs static cpu	RTSS	Departments_of_CS/ECE_&_Center_for_Embedded_Syst._Res. North_Carolina_State_Univ. Raleigh NC USA
565611	harini_ramaprasad frank_mueller	tighten the bounds on feasible preemption point	cache have become invaluable for higherend architecture to hide in part the increase gap between processor speed and memory access time while the effect of cache on timing predictability of single realtime task have be the focus of much research bound the overhead of cache warmup after preemption remain a challenging problem particularly for datum cache this paper make multiple contribution first we bind the penalty of cache interference for realtime task by provide accurate prediction of the datum cache behavior across preemption include instruction cache and pipeline effect for every task we derive datum cache reference pattern for all scalar and nonscalar reference we show that when consider cache preemption the critical instance do not occur upon simultaneous release of all task second we develop analysis method to calculate tight upper bound on the number of possible preemption point for each job of a task and consider the worstcase placement of these preemption point partial timing of a job be perform up to a preemption point use the cache reference pattern the effect of cache interference be then analyze use a settheoretic approach which identify the number and location of additional miss due to preemption a feedback mechanism provide the means to interact with the timing analyzer which subsequently time another interval of a job bound by the next preemption significant improvement in tighten bound of up to a order of magnitude over two prior method and up to half a magnitude over a third prior method be obtain by experiment for lrb a rrb the number of preemption lrb b rrb the wcet and lrb c rrb the response time of a task overall this work contribute lrb 1 rrb by formulate a new critical instance under cache preemption lrb 2 rrb by prove a new analysis method to derive bound on the number of preemption and lrb 3 rrb by determine actual preemption point when calculate the preemption delay under consideration of datum cache doi 101109 rtss 200649 preemption wcet data cache predictability realtime task	RTSS	North_Carolina_State_University USA
565628	wankang_zhao david_b._whalley christopher_a._healy frank_mueller	wcet code positioning	some processorsi ncur a pipeline delay whenever a instruction transferscontrol to a targetthat be not the next sequential instruction compiler writersattempt to reduce these delay by position the basic block within a function to minimize the number of unconditional jump and take conditional branch that occurs uchac ode position algorithm be traditionally drive by profile datum represent typical programe xecution wherep airso f block areplace in contiguous order when the transition between these block occur most frequentlyi nt he paper we describe a approacht op erform code position without profile in a attempt to reduce wcet instead of aceto ur compiler interact with a timing analyzer to obtain wcet path information to guide the blockp ositioning t he result show over a 9 average reduction in wcet be achieve after code positioning be perform and we greedy wcet code position algorithm always achieve optimal result for we benchmark suite doi 101109 real 200455 code positioning wcet acet positioning embed	RTSS	North_Carolina_State_University
572816	frank_mueller david_b._whalley	efficient onthefly analysis of program behavior and static cache simulation		SAS	
575261	tushar_mohan bronis_r._de_supinski sally_a._mckee frank_mueller andy_yoo martin_schulz	identify and exploit spatial regularity in datum memory reference	the grow processormemory performance gap cause the performance of many code to be limit by memory access if know to exist in a application stride memory access form stream can be target by optimization such as prefetching relocation remapping and vector load undetected they can be a significant source of memory stall in loop exist streamdetection mechanism either require special hardware which may not gather statistics for subsequent analysis or be limit to compiletime detection of array access in loop formally little treatment have be accord to the subject the concept of locality fail to capture the existence of stream in a program s memory access the contribution of this paper be as follow first we define spatial regularity as a means to discuss the presence and effect of stream second we develop measure to quantify spatial regularity and we design and implement a online parallel algorithm to detect stream and hence regularity in run application third we use example from real code and common benchmark to illustrate how derive stream statistics can be use to guide the application of profiledriven optimization overall we demonstrate the benefit of we novel regularity metric as a instrument to detect potential for code optimization affect memory performance doi 101145 10489351050199 endorsement prefetching university of california regularity memory access	SC	North_Carolina_State_University Raleigh NC
575624	leo_t._yang xiaosong_ma frank_mueller	crossplatform performance prediction of parallel application use partial execution	performance prediction across platform be increasingly important in today s diverse computing environment as both program and they developer face unprecedented wide choice in execution platform crossmachine execution time prediction with reasonable accuracy equally benefit scheduling decision of grid job and scientist in they research and development planning in this paper we derive a affordable method approach crossplatform performance translation base on the notion of relative performance between two platform we argue that relative performance can often be observe without run a parallel application in full this paper show that it suffice to observe very short partial execution of a application since most parallel code be iterative and behave in a predictable manner after a minimal startup period this novel prediction approach be observationbased and do not require program modeling code analysis or architectural simulation we performance result demonstrate that performance prediction derive from partial application execution can yield highly accurate result at a low cost it be this accuracy combine with the simplicity of the model that make we approach highly intriguing as underline by we experiment across a large number of platform lrb ten parallel machine with eight distinct architecture rrb and highperformance application lrb four realworld parallel simulation code rrb we also assess the limitation of we model and identify future research direction on observationbased performance prediction partial execution performance prediction hardware platform portability prediction approach	SC	North_Carolina_State_University Raleigh
575649	michael_noeth jaydeep_marathe frank_mueller martin_schulz bronis_r._de_supinski	poster reception scalable compression and replay of communication trace in massively parallel environment	to be successful the research agenda for a novel control view of cognition should foresee more detailed computationally specify process model of cognitive operation include higher cognition these model should cover all domain of cognition include those cognitive ability that can be characterize as online interactive loop and detach form of cognition that depend on internally generate neuronal processing doi 101017 s0140525x15001648	SC	
575965	zhe_zhang chao_wang sudharshan_s._vazhkudai xiaosong_ma gregory_g._pike john_w._cobb frank_mueller	optimize center performance through coordinate datum staging scheduling and recovery	procurement and the optimize utilization of petascale supercomputer and center be a renewed national priority sustained performance and availability of such large center be a key technical challenge significantly impact they usability storage system be know to be the primary fault source lead to datum unavailability and job resubmission this result in reduce center performance partially due to the lack of coordination between io activity and job scheduling in this work we propose i the coordination of job scheduling with datum stagingoffloading i and i ondemand stage datum reconstruction i to address the availability of job input datum and to improve centerwide performance fundamental to both mechanism be the efficient management of transient datum in the way it be i schedule i and i recover i collectively from a center s standpoint these technique optimize resource usage and increase its dataservice availability from a user s standpoint they reduce the job turnaround time and optimize the allocate time usage doi 101145 13626221362696 stage metadata job scheduling job submission	SC	North_Carolina_State_University
576117	chao_wang frank_mueller christian_engelmann stephen_l._scott	proactive processlevel live migration in hpc environment	as the number of node in highperformance computing environment keep increase fault be become common place reactive fault tolerance lrb ft rrb often do not scale due to massive io requirement and rely on manual job resubmission this work complement reactive with proactive ft at the process level through health monitoring a subset of node failure can be anticipate when one s health deteriorate a novel processlevel live migration mechanism support continued execution of application during much of process migration this scheme be integrate into a mpi execution environment to transparently sustain healthinflicted node failure which eradicate the need to restart and requeue mpi job experiment indicate that 16 5 seconds of prior warning be require to successfully trigger live process migration while similar operating system virtualization mechanism require 1324 seconds this selfhealing approach complement reactive ft by nearly cut the number of checkpoint in half when 70 of the fault be handle proactively doi 101145 14133701413414 fault tolerance process migration number of node hpc cr	SC	North_Carolina_State_University Raleigh NC
587996	e._w._giering frank_mueller theodore_p._baker	implement ada 9x features use posix threads design issues	the draft standard posix threads extension provide a application program interface to operate system service support the creation and execution of multiple thread of control within a single process where ada be implement over a operating system that support posixlike thread service there be good reason to implement the ada task as posix thread this paper explore some of the design issue involve in implement ada 9x task construct on a system support posix thread doi 101145 170657170736 operating posix threads	TRI-Ada	
587997	e._w._giering frank_mueller theodore_p._baker	feature of the gnu ada runtime library	the gnu ada runtime library lrb gnarl rrb be be develop to support ada 9x task for the gnu nyu ada translator lrb gnat rrb together they form a portable freely distributable ada 9x translation system gnarl and gnat communicate through a welldeened procedural interface facilitate they independent development among the design goal of this translation system be portability interoperability with other language lrb in particular c rrb eeciency and user extensibility this paper provide a overview of how the gnarl support these goal	TRI-Ada	
588055	dragan_macos frank_mueller	the rendezvous be dead long live the protected object	this paper outline the shortcoming of rendezvous and the advantage of protected object as a means of synchronization in ada 95 a common ada benchmark suite aces give the misleading impression that protect object be cheaper per se this work show that the main beneet of protected object stem from the potential to reduce the number of context switch base on the latter observation a general model to translate rendezvous into protected object be develop this model be further reen to replace entire server task that make call to or accept rendezvous a quantitative evaluation show the beneet of protected object for each approach and illustrate that the number of context switch can be reduce at least by 50 when task with rendezvous be replace by protected object result in signiicant execution time savings for application require many synchronization 1 introduction in a concurrent language entity for threaded execution lrb task rrb and method of synchronization allow the expression of potential parallelism method for synchronization include mutual exclusion with conditional synchronization semaphore monitor remote procedure call message passing and rendezvous just to name the most common feature 1 rsb ada task traditionally employ rendezvous as the only means of synchronization cooperate task could use rendezvous to directly communicate with each other much alike synchronous bidirectional messagepassing style however if the access to a shared resource have to be arbitrate a single server task be use that respond to lock and unlock entry call the creation of a server task would not have be necessary have other synchronization mechanism be adopt for this case ada 95 xed this shortcoming by provide protected object as another option for synchronization protect object be add to the language standard in order to provide for more doi 101145 289524289653 saving context switch monitor rendezvous protected object	SIGAda	
636203	frank_mueller	a library implementation of posix threads under unix	recently there have be a effort to specify a ieee standard for portable operating system for open system call posix one part of it the posix 10034 a thread extension lrb pthread for short rrb lsb 12 rsb describe the interface for lightweight thread that rely on share memory and have a smaller context frame than process this paper describe and evaluate the design and implementation of a library of pthreads call that be solely base on unix it show that a library implementation be feasible and can result in good performance this work can also be use as a comparison of the performance of other implementation or as a prototyping testing and debugging system in the regular unix environment finally some problem with the pthreads standard be identify openmp pthread posix primitive unix	USENIX_Winter	
652994	frank_mueller	2006 wcet preface proceedings of the 6th intl workshop on worstcase execution time analysis lrb wcet 06 rrb		WCET	
652995	frank_mueller	2006 wcet abstracts collection 6th intl workshop on worstcase execution time lrb wcet rrb analysis	on the 4th of july 2006 the 6th international workshop on worstcase execution time analysis lrb wcet 06 rrb be hold in dresden germany colocate with the 18th euromicro international conference on realtime systems lrb ecrts 06 rrb both with support of euromicro technical committee the goal of the workshop be to bring together people from academia tool vendor and user in industry that be interested in all aspect of timing analysis for realtime system the workshop provide a relax forum to present and discuss new idea new research direction and to review current trend in this area the workshop be base on short presentation that encourage discussion by the attendee abstract of the presentation be put together in this paper links to extend abstract or full papers be provide the rst section direct to the preface of the proceedings both with support of euromicro technical committee the goal of the workshop be to bring together people from academia tool vendor and user in industry that be interested in all aspect of timing analysis for realtime system the workshop provide a relax forum to present and discuss new idea new research direction and to review current trend in this area the workshop be base on short presentation that should encourage discussion by the attendee research direction academia forum attendees realtime systems	WCET	
709580	prasanth_ganesan ramnath_venugopalan pushkin_peddabachagari alexander_g._dean frank_mueller mihail_l._sichitiu	analyze and modeling encryption overhead for sensor network node	recent research in sensor network have raise security issue for small embedded device security concern be motivate by the deployment of a large number of sensory device in the field limitations in process power battery life communication bandwidth and memory constrain the applicability of exist cryptography standard for small embedded device a mismatch between wide arithmetic for security lrb 32 bit word operation rrb and embedded datum bus width lrb often only 8 or 16 bit rrb combine with lack of certain operation lrb eg multiply rrb in the isa present other challengesthis paper offer two contribution first a survey investigate the computational requirement for a number of popular cryptographic algorithm and embedded architecture be present the objective of this work be to cover a wide class of commonly use encryption algorithm and to determine the impact of embedded architecture on they performance this will help designer predict a system s performance for cryptographic task second method to derive the computational overhead of embedded architecture in general for encryption algorithm be develop this allow one to project computational limitation and determine the threshold of feasible encryption scheme under a set of the constraint for a embedded architectureexperimental measurement indicate uniform cryptographic cost for each encryption class and each architecture class and negligible impact of cache rc4 be show to outperform rc5 for the motes atmega platform contrary to the choice of rc5 for the motes project a choice drive in large by memory constraint the analytical model allow to assess the impact of arbitrary embedded architecture as a multivariant function for each encryption scheme overall we result be not only valuable to assess the feasibility of encryption scheme for exist embedded architecture they also extend to assess the feasibility of encryption method for new algorithm and architecture for sensor system doi 101145 941350941372 encryption scheme encryption isa support risc embed architecture different encryption large decryption spin	Wireless_Sensor_Networks_and_Applications	North_Carolina_State_University Raleigh NC
765161	frank_mueller daniel_j._muller dirk_labudde	analysis assistant for singlemolecule force spectroscopy datum on membrane protein mptv	unlabelled forcedistance lrb fd rrb curve of single membrane protein reveal information on inter and intramolecular interaction occur within a protein and between protein however the analysis of singlemolecule force spectroscopy datum be a time consuming and complex process require objective criterion in most case the user require additional information to interpret fd curve therefore we develop a software assistant represent the force or molecular interaction pattern and the topology or the 3d structure of the membrane protein this representation establish a basis for detailed interpretation of the protein structure and its underlying molecular interaction various integrate bioinformatic feature further assist in the interpretation of measure and assign molecular interaction that determine membrane protein folding structure stability and function web query and program about the topology be directly link motif helix type representation of venn diagram and the complete functionality of the program jmol belong to it availability the program mptv be freely available from the website at httpwwwbioforscherdemptvhtm doi 101093 bioinformaticsbtl138 folding protein structure inter molecular interaction membrane protein	Bioinformatics	
980242	thomas_roblitz frank_mueller oliver_buhn	legosim simulation of embedded kernel over pthread		ACM_Journal_of_Educational_Resources_in_Computing	
988641	nirmit_desai frank_mueller	scalable hierarchical lock for distribute system	middleware component be become increasingly important as application share computational resource in distribute environment such as highend cluster with ever larger number of processor computational grid and increasingly large server farm one of the main challenge in such environment be to achieve scalability of synchronization in general concurrency service arbitrate resource request in distribute system but concurrency protocol currently lack scalability add such guarantee enable resource sharing and computing with distribute object in system with a large number of node the objective of we work be to enhance middleware service to provide scalability of synchronization and to support state replication in distribute system we have design and implement a middleware protocol in support of these objective its essence be a peertopeer protocol for multimode hierarchical lock which be applicable to transactionstyle processing and distribute agreement we demonstrate high scalability combine with low response time in highperformance cluster environment we technical contribution be a novel fully decentralize hierarchical lock protocol to enhance concurrency in distribute resource allocation follow the specification of general concurrency service for largescale datum and object repository we experiment on a ibm sp show that the number of message approach a asymptote at 15 node from which point on the message overhead be in the order of 39 message per request depend on system parameter at the same time response time increase linearly with a proportional increase in request and consequently higher concurrency level specifically in the range of up to 80 node response time under 10 msec be observe for critical section that be one 25th the size of noncritical code the high degree of scalability and responsiveness of we protocol be due in large to a high level of concurrency upon resolve request combine with dynamic path compression for request propagation path we approach be not only applicable to corba its principle be show to provide benefit to general distribute concurrency service and transaction model besides its technical strength we approach be intriguing due to its simplicity and its wide applicability range from largescale cluster to serverstyle computing doi 101016 jjpdc 200310001 concurrency asymptote high scalability middleware service number of message	J._Parallel_Distrib._Comput.	Department_of_Computer_Science North_Carolina_State_University 448_EGRC Raleigh NC
989921	jeffrey_s._vetter frank_mueller	communication characteristic of largescale scientific application for contemporary cluster architecture	this paper examine the explicit communication characteristic of several sophisticated scientific application which by themselves constitute a representative suite of publicly available benchmark for large cluster architecture by focus on the message passing interface lrb mpi rrb and by use hardware counter on the microprocessor we observe each application s inherent behavioral characteristic pointtopoint and collective communication and floatingpoint operation furthermore we explore the sensitivity of these characteristic to both problem size and number of processor we analysis reveal several striking similarity across we diverse set of application include the use of collective operation especially those collective with very small datum payload we also highlight a trend of novel application parting with regimented static communication pattern in favor of dynamically evolve pattern as evidence by we experiment on application that use implicit linear solver and adaptive mesh refinement overall we study contribute a better understanding of the requirement of current and emerge paradigm of scientific computing in term of they computation and communication demand doi 101109 ipdps 20021015504 scientific application collective operation communication characteristic mpi parallel application	J._Parallel_Distrib._Comput.	Department_of_Computer_Science North_Carolina_State_University 448_EGRC Raleigh NC
1053298	joachim_wegener frank_mueller	a comparison of static analysis and evolutionary test for the verification of timing constraint	this paper contrast two method to verify timing constraint of realtime application the method of static analysis predict the worstcase and bestcase execution time of a task s code by analyze execution path and simulate processor characteristic without ever execute the program or require the program s input evolutionary testing be a iterative testing procedure which approximate the extreme execution time within several generation by execute the test object dynamically and measure the execution time the input be guide yield gradually tighter prediction of the extreme execution time we examine both approach on a number of real world example the result show that static analysis and evolutionary testing be complementary method which together provide upper and lower bound for both worstcase and bestcase execution time doi 101109 rttas 1998683198 wcet actual evolutionary testing schedulability static analysis	Real-Time_Systems	Department_of_Computer_Science North_Carolina_State_University Raleigh NC_27695-8206_mueller@cs.ncsu.edu
1053302	randall_t._white frank_mueller christopher_a._healy david_b._whalley marion_g._harmon	timing analysis for datum and wraparound fill caches	the contribution of this paper be twofold first a automatic toolbased approach be describe to bind worstcase datum cache performance the approach work on fully optimize code perform the analysis over the entire control ow of a program detect and exploit both spatial and temporal locality within datum reference and produce result typically within a few seconds result obtain by run the system on representative program be present and indicate that timing analysis of datum cache behavior usually result in signiicantly tighter worstcase performance prediction second a method to deal with realistic cache lling approach namely wraparoundlling for cache miss be present as a extension to pipeline analysis wraparound ll analysis be more challenging than traditional cache analysis since the word within a program line be load into cache in diierent cycle accord to a predetermined sequence rather than all at the same time result indicate that worstcase timing prediction become signiicantly tighter when wraparoundll analysis be perform overall the contribution of this paper be a comprehensive report on method and result of worstcase timing analysis for datum cache and wraparound cache the approach take be unique and provide a considerable step toward realistic worstcase execution time prediction of contemporary architecture and its use in schedulability analysis for hard realtime system	Real-Time_Systems	
1053323	yifan_zhu frank_mueller	feedback edf scheduling of realtime tasks exploiting dynamic voltage scale	many embedded system be constrain by limit on power consumption which be reflect in the design and implementation for conserve they energy utilization dynamic voltage scaling lrb dvs rrb have become a promising method for embedded system to exploit multiple voltage and frequency level and to prolong they battery life however pure dvs technique do not perform well for system with dynamic workload where the job execution time vary significantly in this paper we present a novel approach combine feedback control with dvs scheme target hard realtime system with dynamic workload we method rely strictly on operate system support by integrate a dvs scheduler and a feedback controller within the earliestdeadlinefirst lrb edf rrb scheduling algorithm each task be divide into two portion the objective within the first portion be to exploit frequency scaling for the average execution time static and dynamic slack be accumulate for each task with slackpassing and preemption handle scheme the objective within the second portion be to meet the hard realtime deadline requirement up to the worstcase execution time follow a lastchance approach feedback control technique make the system capable of select the right frequency and voltage setting for the first portion as well as guarantee hard realtime requirement for the overall task a feedback control model be give to describe we feedback dvs scheduler which be use to analyze the system s stability simulation experiment demonstrate the ability of we algorithm to save up to 29 more energy than previous work for task set with different dynamic workload characteristic doi 101007 s1124100527443 wcet dvs feedback control deadline realtime systems	Real-Time_Systems	Department_of_Computer_Science/Center_for_Embedded_Systems_Research North_Carolina_State_University Raleigh USA_27695-7534
1053324	wankang_zhao william_c._kreahling david_b._whalley christopher_a._healy frank_mueller	improving wcet by apply worstcase path optimization	it be advantageous to perform compiler optimization that attempt to lower the worstcase execution time lrb wcet rrb of a embedded application since task with lower wcet be easier to schedule and more likely to meet they deadline compiler writer in recent year have use profile information to detect the frequently execute path in a program and there have be considerable effort to develop compiler optimization to improve these path in order to reduce the averagecase execution time lrb acet rrb in this paper we describe a approach to reduce the wcet by adapt and apply optimization design for frequent path to the worstcase lrb wc rrb path in a application instead of profile to find the frequent path we wcet path optimization use feedback from a timing analyzer to detect the wc path in a function since these pathbased optimization may increase code size the subsequent effect on the wcet due to these optimization be measure to ensure that the worstcase path optimization actually improve the wcet before commit to a code size increase we evaluate these wc path optimization and present result show the decrease in wcet versus the increase in code size a preliminary version of this paper entitle improving wcet by optimize worstcase path appear in the 2005 realtime and embed technology and application symposium doi 101007 s1124100686434 wcet acet dsp timing analyzer path optimization	Real-Time_Systems	Computer_Science_Department North_Carolina_State_University USA
1066870	christian_engelmann stephen_l._scott david_e._bernholdt narasimha_raju_gottumukkala chokchai_leangsuksun jyothish_varma chao_wang frank_mueller aniruddha_g._shet p._sadayappan	molar adaptive runtime support for highend computing operating and runtime system	molar be a multiinstitutional research effort that concentrate on adaptive reliable and efficient operating and runtime system lrb osr rrb solution for ultrascale highend scientific computing on the next generation of supercomputer this research address the challenge outline in fastos lrb forum to address scalable technology for runtime and operating system rrb and hecrtf lrb highend computing revitalization task force rrb activity by explore the use of advanced monitoring and adaptation to improve application performance and predictability of system interruption and by advance computer reliability availability and serviceability lrb ras rrb management system to work cooperatively with the osr to identify and preemptively resolve system issue this paper describe recent research of the molar team in advance ras for highend computing osrs doi 101145 11313221131337 molar ras	Operating_Systems_Review	North_Carolina_State_University Raleigh NC
1067876	frank_mueller	the 3rd acm sigplan workshop on languages compilers and tool for realtime systems lrb workshop report rrb		SIGPLAN_Notices	
1077178	wankang_zhao david_b._whalley christopher_a._healy frank_mueller	improving wcet by apply a wc codepositioning optimization	application in embedded system often need to meet specified timing constraint it be advantageous to not only calculate the worstcase execution time lrb wcet rrb of a application but to also perform transformation which reduce the wcet since a application with a lower wcet will be less likely to violate its timing constraint some processor incur a pipeline delay whenever a instruction transfer control to a target that be not the next sequential instruction codepositioning optimization attempt to reduce these delay by position the basic block to minimize the number of unconditional jump and take conditional branch that occur traditional codepositioning algorithm use profile datum to find the frequently execute edge between basic block then minimize the transfer of control along these edge to reduce the average case execution time lrb acet rrb this paper introduce a wcet codepositioning optimization drive by the worstcase lrb wc rrb path information from a timing analyzer to reduce the wcet instead of acet this wcet optimization change the layout of the code in memory to reduce the branch penalty along the wc path unlike the frequency of edge in traditional profiledriven code positioning the wc path may change after codepositioning decision be make thus wcet code positioning be inherently more challenging than acet code positioning the experimental result show that this optimization typically find the optimal layout of the basic block with the minimal wcet the result show over a 7 percnt reduction in wcet be achieve after code positioning be perform doi 101145 11138411113842 layout code positioning wcet acet timing constraint	TACO	North_Carolina_State_University Raleigh NC
1077185	jaydeep_marathe frank_mueller bronis_r._de_supinski	analysis of cachecoherence bottleneck with hybrid hardwaresoftware technique	application performance on highperformance sharedmemory system be often limit by share pattern result in cachecoherence bottleneck current approach to identify coherence bottleneck incur considerable runtime overhead and do not scale we present two novel hardwareassisted coherenceanalysis technique that reduce trace size by two order of magnitude over full trace first hardware performance monitoring be combine with capture store in software to provide a lossytrace mechanism which be a order of magnitude faster than softwareinstrumentationbased fulltracing and retain accuracy second select longlatency load be instrumented via binary rewrite which provide even higher accuracy and control over trace but require additional overhead doi 101145 11879761187978	TACO	North_Carolina_State_University Raleigh NC
1079604	christopher_a._healy robert_d._arnold frank_mueller david_b._whalley marion_g._harmon	bound pipeline and instruction cache performance	predict the execution time of code segment in realtime system be challengingm ost recently design machine contain pipeline and cache pipeline hazard may result in multicycle delay instruction or datum memory reference may not be find in cache and these miss typically requireseveral cycle to resolvew hether a instruction will stall due to apipeline hazardoracache miss depend on the dynamic sequence of previous instruction execute and memory reference perform furthermore these penalty aren ot independent since delay due to pipeline stall and cache miss penalty may overlap this paper describe a approachf or bound the worst and bestcase performance of large code segment on machine that exploit both pipelining and instruction cachingf irst a method be use to analyze a program scontrol flow to statically categorize the caching behavior of eachinstruction next these categorization areus in the pipeline analysis of sequence of instruction represent path within the program a timing analyzer use the pipeline path analysis to estimate the worst and bestcase execution performance of eachl oop and function in the program finally ag raphical user interface be invoke that allow a user to request timing prediction on portion of the program the result indicate that the timing analyzer efficiently produce tight prediction of worst and bestcase performance for pipelining and instruction caching doi 101109 12743411 wcet pipeline hit cfg timing analyzer	IEEE_Trans._Computers	
1098625	kiran_seth aravindh_anantaraman frank_mueller eric_rotenberg	fast frequencyaware static timing analysis	energy be a valuable resource in embedded system as the lifetime of many such system be constrain by they battery capacity recent advance in processor design have add support for dynamic frequencyvoltage scaling lrb dvs rrb for save energy recent work on realtime scheduling focus on save energy in static as well as dynamic scheduling environment by exploit idle time and slack because of early task completion for dvs of subsequent task these scheduling algorithm rely on i a priori i knowledge of worstcase execution time lrb wcet rrb for each task they assume that dvs have no effect on the worstcase execution cycle lrb wcec rrb of a task and scale the wcet accord to the processor frequency however for system with memory hierarchy the wcec typically i do i change under dvs because of requency modulation hence current assumption use by dvs scheme result in a highly exaggerated wcet this paper contribute novel technique for tight and flexible static timing analysis particularly wellsuited for dynamic scheduling scheme the technical contribution be as follow lrb 1 rrb we assess the problem of change execution cycle owe to scale technique lrb 2 rrb we propose a parametric approach toward bound the wcet statically with respect to the frequency use a parametric model we can capture the effect of change in frequency on the wcec and thus accurately model the wcet over any frequency range lrb 3 rrb we discuss design and implementation of the frequencyaware static timing analysis lrb fast rrb tool base on we prior experience with static timing analysis lrb 4 rrb we demonstrate in experiment that we fast tool provide safe upper bound on the wcet which be tight the fast tool allow we to capture the wcet of six benchmark use equation that overestimate the wcet by less than 1 percnt fast equation can also be use to improve exist dvs scheduling scheme to ensure that the effect of frequency scaling on wcet be consider and that the wcet use be i not i exaggerated lrb 5 rrb we leverage three dvs scheduling scheme by incorporate fast into they and by show that the energy consumption further decrease lrb 6 rrb we compare experimental result use two different energy model to demonstrate or verify the validity of simulation method to the best of we knowledge this study of dvs effect on timing analysis be unprecedented doi 101145 11323571132364 wcet fast dvs static cpu	ACM_Trans._Embedded_Comput._Syst.	North_Carolina_State_University Raleigh NC
1098649	frank_mueller per_stenstrom	introduction to the special issue	the national institute of mental health recently launch the research domain criterion lrb rdoc rrb the rdoc be a initiative to improve classification of mental health concern by promote research on the brain mechanism underlie these concern with the ultimate goal of develop intervention that target these brain mechanism a key focus of rdoc involve open new line of research examine patient response on biological measure the rdoc present unique challenge to mental health professional who work with child and adolescent indeed mental health professional rarely integrate biological measure into clinical assessment thus rdoc s ability to improve patient care rest in part on the development of strategy for implement biological measure within mental health assessment further mental health professional already carry out comprehensive assessment that frequently yield inconsistent finding these inconsistency have historically pose challenge to interpret research finding as well as assessment outcome in practice setting in this introductory article we review key issue that inform the development of a special issue of article demonstrate method for implement lowcost measure of physiological function in clinical child and adolescent assessment we also outline a conceptual framework inform by theoretical work on use and interpret multiple informant clinical report lrb de los reyes thomas goodman kundey 2013 rrb to guide hypothesis testing when use physiological measure within clinical child and adolescent assessment this special issue and the conceptual model describe in this article may open up new line of research testing paradigm for implement clinically feasible physiological measure in clinical child and adolescent assessment doi 101080 153744162014891227	ACM_Trans._Embedded_Comput._Syst.	
1098706	yifan_zhu frank_mueller	exploit synchronous and asynchronous dvs for feedback edf scheduling on a embedded platform	contemporary processor support dynamic voltage scaling lrb dvs rrb to reduce power consumption by vary processor voltagefrequency dynamically we develop poweraware feedback dvs algorithm for hard realtime system that adapt to dynamically change workload the algorithm lower execution speed while guarantee timing constraint we study energy consumption for synchronous and asynchronous dvs switching on a powerpc board energy measure via datum acquisition be reduce up to 70 percnt over na 239 ve dvs for we feedback scheme with 24 percnt peak savings over previous algorithm these result albeit differ in quantity confirm trend observe under simulation they be the first of they kind on a embedded board doi 101145 13249691324972 dv	ACM_Trans._Embedded_Comput._Syst.	North_Carolina_State_University Raleigh North_Carolina
1098727	reinhard_wilhelm jakob_engblom andreas_ermedahl niklas_holsti stephan_thesing david_b._whalley guillem_bernat christian_ferdinand reinhold_heckmann tulika_mitra frank_mueller isabelle_puaut peter_p._puschner jan_staschulat per_stenstrom	the worstcase executiontime problem overview of method and survey of tool	the determination of upper bound on execution time commonly call worstcase execution time lrb wcet rrb be a necessary step in the development and validation process for hard realtime system this problem be hard if the underlie processor architecture have component such as cache pipeline branch prediction and other speculative component this article describe different approach to this problem and survey several commercially available tool sup 1 sup and research prototype doi 101145 13473751347389 safe case execution time wcet worstcase timing analysis realtime systems	ACM_Trans._Embedded_Comput._Syst.	
1123952	sebastian_unger frank_mueller	handle irreducible loop optimize node splitting versus djgraph	this paper address the question of how to handle irreducible region during optimization which have become even more relevant for contemporary processor since recent vliwlike architecture highly rely on instruction scheduling the contribution of this paper be twofold first a method of optimize node splitting to transform irreducible region of control flow into reducible region be formally define and its correctness be show this method be superior to approach previously publish since it reduce the number of replicate node by comparison second three method that handle region of irreducible control flow be evaluate with respect to they impact on compiler optimization first traditional node splitting be evaluate second optimize node splitting be implement third djgraph be utilize to recognize nesting of irreducible lrb and reducible rrb loop and apply common loop optimization extend for irreducible loop experiment compare the performance of these approach with unrecognized irreducible loop that can not be subject to loop optimization which be typical for contemporary compiler measurement show improvement of 1 to 40 percnt for these method of handle irreducible loop over the unoptimized case optimize node splitting may be choose to retrofit exist compiler since it have the advantage that it only require few change to a optimize compiler while limit the code growth of compile program compare to traditional node splitting recognize loop via djgraph should be choose for new compiler development since it require more change to the optimizer but do not significantly change the code size of compile program while yield comparable improvement handle irreducible loop should even yield more benefit for exploit instructionlevel parallelism of modern architecture in the context of global instruction scheduling and optimization technique that may introduce irreducible loop such as enhance modulo scheduling doi 101145 567097567098 control flow reducible latter techniques sophisticated compiler node split irreducible instruction scheduling	ACM_Trans._Program._Lang._Syst.	North_Carolina_State_University Raleigh NC
1124057	jaydeep_marathe frank_mueller tushar_mohan sally_a._mckee bronis_r._de_supinski andy_yoo	metric memory trace via dynamic binary rewrite to identify cache inefficiency	with the diverge improvement in cpu speed and memory access latency detect and remove memory access bottleneck become increasingly important in this work we present metric a software framework for isolate and understand such bottleneck use partial access trace metric extract access trace from execute program without special compiler or linker support we make four primary contribution first we present a framework for extract partial access trace base on dynamic binary rewrite of the execute application second we introduce a novel algorithm for compress these trace the algorithm generate constant space representation for regular access occur in nested loop structure third we use these trace for offline incremental memory hierarchy simulation we extract symbolic information from the application executable and use this to generate detailed sourcecode correlate statistics include perreference metric cache evictor information and stream metric finally we demonstrate how this information can be use to isolate and understand memory access inefficiency this illustrate a potential advantage of metric over compiletime analysis for sample code particularly when interprocedural analysis be require doi 101145 12163741216380 metric memory access access trace dynamic binary rewrite	ACM_Trans._Program._Lang._Syst.	North_Carolina_State_University Raleigh NC
1126241	jaydeep_marathe frank_mueller	sourcecodecorrelated cache coherence characterization of openmp benchmark	cache coherence in sharedmemory multiprocessor system have be study mostly from a architecture viewpoint often by means of aggregate metric in many case aggregate event provide insufficient information for programmer to understand and optimize the coherence behavior of they application a better understanding would be give by source code correlation of not only aggregate event but also finer granularity metric directly link to highlevel source code construct such as source line and datum structure in this paper we explore a novel applicationcentric approach to study coherence traffic we develop a coherence analysis framework base on incremental coherence simulation of actual reference trace we provide tool support to extract these reference trace and synchronization information from openmp thread at runtime use dynamic binary rewrite of the application executable these trace be feed to ccsim we cachecoherence simulator the novelty of ccsim lie in its ability to relate lowlevel cache coherence metric lrb such as coherence miss and they causative invalidation rrb to highlevel source code construct include source code location and datum structure we explore the degree of freedom in interleave datum trace from different processor and assess simulation accuracy in comparison to metric obtain from hardware performance counter we quantitative result show that 1 rrb cache coherence traffic can be simulated with a considerable degree of accuracy for spmd program as the invalidation traffic closely match the corresponding hardware performance counter 2 rrb detailed highlevel coherence statistics be very useful in detect isolate and understand coherence bottleneck we use ccsim with several wellknown benchmark and find coherence optimization opportunity lead to significant reduction in coherence traffic and savings in wallclock execution time doi 101109 tpds 20071058 saving coherence hardware performance counter acm simulator	IEEE_Trans._Parallel_Distrib._Syst.	Dept._of_Comput._Sci. North_Carolina_State_Univ. Raleigh NC
1212535	abhik_sarkar frank_mueller harini_ramaprasad sibin_mohan	pushassisted migration of realtime task in multicore processor	multicore be become ubiquitous not only in generalpurpose but also embedded computing this trend be a reflexion of contemporary embedded application pose steadily increase demand in process power on such platform prediction of timing behavior to ensure that deadline of realtime task can be meet be become increasingly difficult while realtime multicore scheduling approach help to assure deadline base on firm theoretical property they reliance on task migration pose a significant challenge to timing predictability in practice task migration actually lrb a rrb reduce timing predictability for contemporary multicore due to cache warmup overhead while lrb b rrb increase traffic on the networkonchip lrb noc rrb interconnect this paper put forth a fundamentally new approach to increase the timing predictability of multicore architecture aim at task migration in embedded environment a task migration between two core impose cache warmup overhead on the migration target which can lead to miss deadline for tight realtime schedule we propose novel microarchitectural support to migrate cache line we scheme show dramatically increase predictability in the presence of crosscore migration experimental result for schedule demonstrate that we scheme enable realtime task to meet they deadline in the presence of task migration we result illustrate that increase in execution time due to migration be reduce by we scheme to level that may prevent deadline miss of realtime task that would otherwise occur we mechanism impose a overhead at a fraction of the task s execution time yet this overhead can be steer to fill idle slot in the schedule i ie i it do not contribute to the execution time of the migrate task overall we novel migration scheme provide a unique mechanism capable of significantly increase timing predictability in the wake of task migration doi 101145 15424521542464 multicore architecture task migration predictability realtime task deadline	LCTES	North_Carolina_State_University Raleigh NC USA
1225438	chao_wang zhe_zhang xiaosong_ma sudharshan_s._vazhkudai frank_mueller	improving the availability of supercomputer job input datum use temporal replication	supercomputer be step into the petascale and exascale era wherein handle hundred of concurrent system failure be a urgent challenge in particular storage system failure have be identify as a major source of service interruption in supercomputer raid solution alone can not provide sufficient storage protection as lrb 1 rrb average disk recovery time be project to grow make raid group increasingly vulnerable to additional failure during datum reconstruction and lrb 2 rrb disklevel datum protection can not mask higherlevel fault such as softwarehardware failure of entire io node this paper present a complementary approach base on the observation that file in the supercomputer scratch space be typically access by batch job whose execution can be anticipate therefore we propose to transparently selectively and temporarily replicate active job input datum by coordinate the parallel file system with the batch job scheduler we have implement the temporal replication scheme in the popular lustre parallel file system and evaluate it with both realcluster experiment and tracedriven simulation we result show that temporal replication allow for fast online datum reconstruction with a reasonably low overall space and io bandwidth overhead doi 101007 s0045000900828 scratch space raid parallel file supercomputer tem	Computer_Science_-_RD	
1238780	jin_ouyang raghuveer_raghavendra sibin_mohan tao_zhang yuan_xie frank_mueller	checkercore enhance a fpga soft core to capture worstcase execution time	embed processor have become increasingly complex result in variable execution behavior and reduce timing predictability on such processor safe timing specification express as bound on the worstcase execution time lrb wcet rrb be generally too loose due to conservative assumption about complex architectural feature time anomaly and programmatic complexity hence exploit the latest architecture may not be a option for embedded system with hard realtime constraint where deadline miss can not be tolerate this work address these shortcoming by contribute checkercore checkercore be a modeenhanced sparc v8 soft core processor synthesize on a fpga during regular execution the core adhere to its original specification but when operate in a special timechecking configuration checkercore execute program irrespective of input and steer execution intentionally along select control flow path such execution allow systematic derivation of worstcase execution time lrb wcet rrb bound this paper present the overall design and implementation of checkercore and also illustrate its use in derive accurate wcet bound for a set of embedded benchmark overall checkercore propose a realistic processor core enhancement that encapsulate processor detail without reveal they to user while support safe bound of wcet to the best of we knowledge this be the first contribution of a wcetenhancing microarchitectural feature besides full processor encapsulation doi 101145 16293951629421 wcet fpga worstcase execution time	CASES	North_Carolina_State_University Raleigh PA USA
1321809	harini_ramaprasad frank_mueller	bound worstcase response times of tasks under pip	schedulability theory in realtime system require prior knowledge of the worstcase execution time lrb wcet rrb of every task in the system one method to determine the wcet be know as static timing analysis determination of the priority among task in such a system require a scheduling policy which could be either preemptive or nonpreemptive while static timing analysis and datum cache analysis be simplify by use a fully nonpreemptive scheduling policy it result in decrease schedulability in prior work a methodology be propose to bind the datacache related delay for realtime task that beside have anonpreemptive region lrb critical section rrb can otherwise be schedule preemptivelywhile the prior approach improve schedulability in comparison to fully nonpreemptive method it be still conservative in its approach due to its fundamental assumption that a task execute in a critical section may not be preempt by any other task in this paper we propose a methodology that incorporate resource sharing policy such as the priority inheritance protocol lrb pip rrb into the calculation of datacache related delay in this approach access to share resource which be the primary reason for critical section within task be control by the resource share policy in addition to maintain correctness of access such policy strive to limit resource access conflict thereby improve the responsiveness of tasksto the best of we knowledge this be the first framework that integrate datacache related delay calculation with resource sharing policy in the context of realtime system doi 101109 rtas 200928 responsiveness wcet preemptive schedulability nonpreemptive	null	
1321957	sibin_mohan frank_mueller	merge state and preserve timing anomaly in pipeline of highend processors	many embedded system be subject to temporal constraint that require advance guarantee on meeting deadline such system rely on static analysis to safely bind worstcase execution lrb wcet rrb bound of task designer of these system be force to avoid stateoftheart processor due to they inherent architectural complexity lrb such as outoforder instruction scheduling rrb that result in nondeterminism this work address this problem by provide novel pipeline analysis technique for characterize the worstcase behavior of realtime system on modern processor architecture we introduce method to capture lrb snapshot rrb pipeline state and to subsequently perform a merge of previously capture snapshot we prove that we pipeline analysis correctly preserve worstcase timing behavior on outoforder lrb ooo rrb processor pipeline we further specifically show that anomalous pipeline effect effectively dilate timing be preserve by we method to the best of we knowledge this method of pipeline analysis and interaction between hardwaresoftware for obtain wcet bound on ooo processor be the first of its kind doi 101109 rtss 200812 pipeline snapshot embed systems microprocessor realtime systems	null	
1339572	michael_noeth prasun_ratn frank_mueller martin_schulz bronis_r._de_supinski	scalatrace scalable compression and replay of communication trace for highperformance computing	characterize the communication behavior of largescale application be a difficult and costly task due to codesystem complexity and long execution time while many tool to study this behavior have be develop these approach either aggregate information in a lossy way through highlevel statistics or produce huge trace file that be hard to handle we contribute a approach that provide order of magnitude smaller if not nearconstant size communication trace regardless of the number of node while preserve structural information we introduce intraand internode compression technique of mpi event that be capable of extract a application s communication structure we further present a replay mechanism for the trace generate by we approach and discuss result of we implementation for bluegenel give this novel capability we discuss its impact on communication tuning and beyond to the best of we knowledge such a concise representation of mpi trace in a scalable manner combine with deterministic mpi call replay be without any precedent a earlier version of this paper appear at ipdps 07 lsb 20 rsb this journal version extend the earlier paper by novel domainspecific intraand internode compression technique a completely redesign internode merge algorithm novel result with a larger class of code result in nearconstant trace size a study to identify the timestep loop and extend related work doi 101016 jjpdc 200809001 tail scalatrace replay mpi rsd	J._Parallel_Distrib._Comput.	North_Carolina_State_University Department_of_Computer_Science Raleigh NC_27695-7534 United_States
1384967	jaydeep_marathe frank_mueller	pfetch software prefetching exploit temporal predictability of memory access stream	cpu speed have increase faster than the rate of improvement in memory access latency in the recent past as a result with program that suffer excessive cache miss the cpu will increasingly be stall wait for the memory system to provide the request memory line prefetch be a b latency hide b technique that tackle this problem if the address of the memory line that miss in cache can be predict sufficiently in advance it can be prefetch into the cache before it be access reduce the effective latency of that access in this paper we develop a novel softwareonly datum prefetch scheme that work at the instruction level and exploit predictability in the access stream to prefetch memory line access in the future work at the instruction level give we a b global b view of memory access pattern across function module and library boundary conceptually we scheme monitor the memory location be access by load and store as well as they b contents b it try to find instance of b predictability b such that the address of a load miss can be predetermined from a limited number of past access we make the follow contribution in this work first we present a novel prefetching strategy that b unify b and generalize a number of past approach that each target a specific source of address predictability specifically we scheme unify all these past approach nextline prefetching selfstride prefetching intraiteration stride prefetching and sameobject prefetching in addition it extend and generalize the spaid scheme for pointer and callintensive program second we present a new thresholdbased approach that address the issue of b prefetch accuracy prefetch timeliness b and b prefetch redundancy b third we assess we scheme both with a cache simulator and on a real machine where we evaluate it with hardware performance counter overall we demonstrate that a significant reduction in l1 cache miss can be achieve for several benchmark on a real machine with we approach doi 101145 15090841509085 prefetching memory access pattern past approaches predictability cpu	Proceedings_of_the_9th_workshop_on_MEmory_performance:_DEaling_with_Applications,_systems_and_architecture	North_Carolina_State_University Raleigh NC
1396886	dragan_macos frank_mueller	the rendezvous be dead long live the protected object	this paper outline the shortcoming of rendezvous and the advantage of protected object as a means of synchronization in ada 95 a common ada benchmark suite aces give the misleading impression that protect object be cheaper per se this work show that the main beneet of protected object stem from the potential to reduce the number of context switch base on the latter observation a general model to translate rendezvous into protected object be develop this model be further reen to replace entire server task that make call to or accept rendezvous a quantitative evaluation show the beneet of protected object for each approach and illustrate that the number of context switch can be reduce at least by 50 when task with rendezvous be replace by protected object result in signiicant execution time savings for application require many synchronization 1 introduction in a concurrent language entity for threaded execution lrb task rrb and method of synchronization allow the expression of potential parallelism method for synchronization include mutual exclusion with conditional synchronization semaphore monitor remote procedure call message passing and rendezvous just to name the most common feature 1 rsb ada task traditionally employ rendezvous as the only means of synchronization cooperate task could use rendezvous to directly communicate with each other much alike synchronous bidirectional messagepassing style however if the access to a shared resource have to be arbitrate a single server task be use that respond to lock and unlock entry call the creation of a server task would not have be necessary have other synchronization mechanism be adopt for this case ada 95 xed this shortcoming by provide protected object as another option for synchronization protect object be add to the language standard in order to provide for more doi 101145 289524289653 saving context switch monitor rendezvous protected object	Proceedings_of_the_1998_annual_ACM_SIGAda_international_conference_on_Ada	Humboldt-Universitt_zu_Berlin Institut_fr_Informatik 10099_Berlin Germany
1429697	frank_mueller	analytically bound datum cache behavior for realtime system	share resource access interference particularly memory and system bus be a big challenge in design predictable realtime system because its worst case behavior can significantly differ in this paper we propose a software base memory throttle mechanism to explicitly control the memory interference we develop analytic solution to compute proper throttle parameter that satisfy schedulability of critical task while minimize performance impact cause by throttle we implement the mechanism in linux kernel and evaluate isolation guarantee and overall performance impact use a set of synthetic and real application doi 101109 ecrts 201232 critical task bus throttle mechanism memory access criticality	null	North_Carolina_State_University
1430763	frank_mueller	exploit hardwaresoftware interaction for analyze embedded system		null	North_Carolina_State_University
1578715	frank_mueller daniel_j._muller dirk_labudde	analysis assistant for singlemolecule force spectroscopy datum on membrane protein mptv	unlabelled forcedistance lrb fd rrb curve of single membrane protein reveal information on inter and intramolecular interaction occur within a protein and between protein however the analysis of singlemolecule force spectroscopy datum be a time consuming and complex process require objective criterion in most case the user require additional information to interpret fd curve therefore we develop a software assistant represent the force or molecular interaction pattern and the topology or the 3d structure of the membrane protein this representation establish a basis for detailed interpretation of the protein structure and its underlying molecular interaction various integrate bioinformatic feature further assist in the interpretation of measure and assign molecular interaction that determine membrane protein folding structure stability and function web query and program about the topology be directly link motif helix type representation of venn diagram and the complete functionality of the program jmol belong to it availability the program mptv be freely available from the website at httpwwwbioforscherdemptvhtm doi 101093 bioinformaticsbtl138 folding protein structure inter molecular interaction membrane protein	Bioinformatics	
1724319	frank_mueller	static cache simulation and its application	this work take a fresh look at the simulation of cache memory it introduce the technique of static cache simulation that statically predict a large portion of cache reference to eeciently utilize this technique a method to perform eecient onthey analysis of program in general be develop and prove correct this method be combine with static cache simulation for a number of application the application of fast instruction cache analysis provide a new framework to evaluate instruction cache memory that outperform even the fastest technique publish static cache simulation be show to address the issue of predict cache behavior contrary to the belief that cache memory introduce unpredictability to realtime system that can not be eeciently analyze static cache simulation for instruction cache provide a large degree of predictability for realtime system in addition a architectural modiication through bitencoding be introduce that provide fully predictable cache behavior even for regular instruction cache without architectural modiication tight bound for the execution time of realtime program can be derive from the information provide by the static cache simulator finally the debugging of realtime application can be enhance by display the timing information of the debugged program at breakpoint the timing information be determine by simulate the instruction cache behavior during program execution and can be use for example to detect miss deadline and locate timeconsuming code portion overall the technique of static cache simulation provide a novel approach to analyze cache memory and have be show to be very eecient for numerous application	null	The_Florida_State_Univ.
